{"version":3,"sources":["../node_modules/bnc-onboard-staging/node_modules/@ledgerhq/hw-transport-u2f/lib-es/TransportU2F.js","../node_modules/bnc-onboard-staging/node_modules/u2f-api/index.js","../node_modules/bnc-onboard-staging/node_modules/u2f-api/lib/u2f-api.js","../node_modules/bnc-onboard-staging/node_modules/u2f-api/lib/google-u2f-api.js"],"names":["wrapU2FTransportError","originalError","message","id","err","webSafe64","base64","replace","attemptExchange","apdu","timeoutMillis","scrambleKey","unwrap","keyHandle","key","result","Buffer","alloc","length","i","wrapApdu","challenge","from","signRequest","version","toString","appId","location","origin","then","response","signatureData","data","substring","slice","transportInstances","TransportU2F","_Transport","_super","_this","this","call","push","value","_open","mark","_callee","_","_args","arguments","wrap","_context","prev","next","undefined","abrupt","stop","_x","apply","_exchange","_callee2","_context2","exchangeTimeout","sent","t0","metaData","code","forEach","t","emit","type","_x2","Promise","resolve","isSupported","list","supported","listen","observer","unsubscribed","descriptor","complete","error","unsubscribe","module","exports","API","chromeApi","isBrowser","navigator","userAgent","isSafari","match","isEDGE","_backend","getBackend","reject","notSupported","u2f","native","window","sign","protocol","MessageChannel","ok","bind","ensureSupport","register","ErrorCodes","ErrorNames","makeError","msg","errorCode","Error","deferPromise","promise","ret","cancel","disconnect","backend","_ensureSupport","registerRequests","signRequests","timeout","Array","isArray","makeDefault","func","global","args","CANCELLED","OK","OTHER_ERROR","BAD_REQUEST","CONFIGURATION_UNSUPPORTED","DEVICE_INELIGIBLE","TIMEOUT","EXTENSION_ID","MessageTypes","Request","Response","SignRequest","SignResponse","RegisterRequest","RegisterResponse","port_","getMessagePort","callback","chrome","runtime","U2F_SIGN_REQUEST","sendMessage","lastError","getIframePort_","getChromeRuntimePort_","port","connect","setTimeout","WrappedChromeRuntimePort_","prototype","postMessage","addEventListener","eventName","handler","name","toLowerCase","onMessage","addListener","console","iframeOrigin","iframe","document","createElement","src","setAttribute","body","appendChild","hasCalledBack","channel","port1","ready","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","responseHandler_","shift","reqId","cb","opt_timeoutSeconds","req","timeoutSeconds","requestId","U2F_REGISTER_REQUEST"],"mappings":"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","file":"static/js/67.082be3d8.chunk.js","sourcesContent":["import _regeneratorRuntime from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _createClass from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  var err = new TransportError(message, id); // $FlowFixMe\n\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu, key) {\n  var result = Buffer.alloc(apdu.length);\n\n  for (var i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n\n  return result;\n} // Convert from normal to web-safe, strip trailing \"=\"s\n\n\nvar webSafe64 = function webSafe64(base64) {\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}; // Convert from web-safe to normal, add trailing \"=\"s\n\n\nvar normal64 = function normal64(base64) {\n  return base64.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"==\".substring(0, 3 * base64.length % 4);\n};\n\nfunction attemptExchange(apdu, timeoutMillis, scrambleKey, unwrap) {\n  var keyHandle = wrapApdu(apdu, scrambleKey);\n  var challenge = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  var signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then(function (response) {\n    var signatureData = response.signatureData;\n\n    if (typeof signatureData === \"string\") {\n      var data = Buffer.from(normal64(signatureData), \"base64\");\n      var result;\n\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nvar transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(function (t) {\n    return t.emit(\"disconnect\");\n  });\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\n\n\nvar TransportU2F = /*#__PURE__*/function (_Transport) {\n  _inherits(TransportU2F, _Transport);\n\n  var _super = _createSuper(TransportU2F);\n\n  _createClass(TransportU2F, null, [{\n    key: \"open\",\n\n    /*\n     */\n\n    /*\n     */\n\n    /**\n     * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n     */\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_) {\n        var _openTimeout,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _openTimeout = _args.length > 1 && _args[1] !== undefined ? _args[1] : 5000;\n                return _context.abrupt(\"return\", new TransportU2F());\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }]);\n\n  function TransportU2F() {\n    var _this;\n\n    _classCallCheck(this, TransportU2F);\n\n    _this = _super.call(this);\n    _this.scrambleKey = void 0;\n    _this.unwrap = true;\n    transportInstances.push(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  _createClass(TransportU2F, [{\n    key: \"exchange\",\n    value: function () {\n      var _exchange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(apdu) {\n        var isU2FError;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey, this.unwrap);\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](0);\n                isU2FError = typeof _context2.t0.metaData === \"object\";\n\n                if (!isU2FError) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                if (isTimeoutU2FError(_context2.t0)) {\n                  emitDisconnect();\n                } // the wrapping make error more usable and \"printable\" to the end user.\n\n\n                throw wrapU2FTransportError(_context2.t0, \"Failed to sign with Ledger device: U2F \" + _context2.t0.metaData.type, \"U2F_\" + _context2.t0.metaData.code);\n\n              case 14:\n                throw _context2.t0;\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 6]]);\n      }));\n\n      function exchange(_x2) {\n        return _exchange.apply(this, arguments);\n      }\n\n      return exchange;\n    }()\n    /**\n     */\n\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey(scrambleKey) {\n      this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n    }\n    /**\n     */\n\n  }, {\n    key: \"setUnwrap\",\n    value: function setUnwrap(unwrap) {\n      this.unwrap = unwrap;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      // u2f have no way to clean things up\n      return Promise.resolve();\n    }\n  }]);\n\n  return TransportU2F;\n}(Transport);\n\nexport { TransportU2F as default };\nTransportU2F.isSupported = isSupported;\n\nTransportU2F.list = function () {\n  return (// this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then(function (supported) {\n      return supported ? [null] : [];\n    })\n  );\n};\n\nTransportU2F.listen = function (observer) {\n  var unsubscribed = false;\n  isSupported().then(function (supported) {\n    if (unsubscribed) return;\n\n    if (supported) {\n      observer.next({\n        type: \"add\",\n        descriptor: null\n      });\n      observer.complete();\n    } else {\n      observer.error(new TransportError(\"U2F browser support is needed for Ledger. \" + \"Please use Chrome, Opera or Firefox with a U2F extension. \" + \"Also make sure you're on an HTTPS connection\", \"U2FNotSupported\"));\n    }\n  });\n  return {\n    unsubscribe: function unsubscribe() {\n      unsubscribed = true;\n    }\n  };\n};","'use strict';\n\nmodule.exports = require('./lib/u2f-api');","'use strict';\n\nmodule.exports = API;\n\nvar chromeApi = require('./google-u2f-api'); // Feature detection (yes really)\n\n\nvar isBrowser = typeof navigator !== 'undefined' && !!navigator.userAgent;\nvar isSafari = isBrowser && navigator.userAgent.match(/Safari\\//) && !navigator.userAgent.match(/Chrome\\//);\nvar isEDGE = isBrowser && navigator.userAgent.match(/Edge\\/1[2345]/);\nvar _backend = null;\n\nfunction getBackend(Promise) {\n  if (!_backend) _backend = new Promise(function (resolve, reject) {\n    function notSupported() {\n      // Note; {native: true} means *not* using Google's hack\n      resolve({\n        u2f: null,\n        native: true\n      });\n    }\n\n    if (!isBrowser) return notSupported();\n    if (isSafari) // Safari doesn't support U2F, and the Safari-FIDO-U2F\n      // extension lacks full support (Multi-facet apps), so we\n      // block it until proper support.\n      return notSupported();\n    var hasNativeSupport = typeof window.u2f !== 'undefined' && typeof window.u2f.sign === 'function';\n    if (hasNativeSupport) resolve({\n      u2f: window.u2f,\n      native: true\n    });\n    if (isEDGE) // We don't want to check for Google's extension hack on EDGE\n      // as it'll cause trouble (popups, etc)\n      return notSupported();\n    if (location.protocol === 'http:') // U2F isn't supported over http, only https\n      return notSupported();\n    if (typeof MessageChannel === 'undefined') // Unsupported browser, the chrome hack would throw\n      return notSupported(); // Test for google extension support\n\n    chromeApi.isSupported(function (ok) {\n      if (ok) resolve({\n        u2f: chromeApi,\n        native: false\n      });else notSupported();\n    });\n  });\n  return _backend;\n}\n\nfunction API(Promise) {\n  return {\n    isSupported: isSupported.bind(Promise),\n    ensureSupport: ensureSupport.bind(Promise),\n    register: register.bind(Promise),\n    sign: sign.bind(Promise),\n    ErrorCodes: API.ErrorCodes,\n    ErrorNames: API.ErrorNames\n  };\n}\n\nAPI.ErrorCodes = {\n  CANCELLED: -1,\n  OK: 0,\n  OTHER_ERROR: 1,\n  BAD_REQUEST: 2,\n  CONFIGURATION_UNSUPPORTED: 3,\n  DEVICE_INELIGIBLE: 4,\n  TIMEOUT: 5\n};\nAPI.ErrorNames = {\n  \"-1\": \"CANCELLED\",\n  \"0\": \"OK\",\n  \"1\": \"OTHER_ERROR\",\n  \"2\": \"BAD_REQUEST\",\n  \"3\": \"CONFIGURATION_UNSUPPORTED\",\n  \"4\": \"DEVICE_INELIGIBLE\",\n  \"5\": \"TIMEOUT\"\n};\n\nfunction makeError(msg, err) {\n  var code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR\n\n  var type = API.ErrorNames['' + code];\n  var error = new Error(msg);\n  error.metaData = {\n    type: type,\n    code: code\n  };\n  return error;\n}\n\nfunction deferPromise(Promise, promise) {\n  var ret = {};\n  ret.promise = new Promise(function (resolve, reject) {\n    ret.resolve = resolve;\n    ret.reject = reject;\n    promise.then(resolve, reject);\n  });\n  /**\n   * Reject request promise and disconnect port if 'disconnect' flag is true\n   * @param {string} msg\n   * @param {boolean} disconnect\n   */\n\n  ret.promise.cancel = function (msg, disconnect) {\n    getBackend(Promise).then(function (backend) {\n      if (disconnect && !backend.native) backend.u2f.disconnect();\n      ret.reject(makeError(msg, {\n        errorCode: -1\n      }));\n    });\n  };\n\n  return ret;\n}\n\nfunction defer(Promise, fun) {\n  return deferPromise(Promise, new Promise(function (resolve, reject) {\n    try {\n      fun && fun(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }));\n}\n\nfunction isSupported() {\n  var Promise = this;\n  return getBackend(Promise).then(function (backend) {\n    return !!backend.u2f;\n  });\n}\n\nfunction _ensureSupport(backend) {\n  if (!backend.u2f) {\n    if (location.protocol === 'http:') throw new Error(\"U2F isn't supported over http, only https\");\n    throw new Error(\"U2F not supported\");\n  }\n}\n\nfunction ensureSupport() {\n  var Promise = this;\n  return getBackend(Promise).then(_ensureSupport);\n}\n\nfunction register(registerRequests, signRequests\n/* = null */\n, timeout) {\n  var Promise = this;\n  if (!Array.isArray(registerRequests)) registerRequests = [registerRequests];\n\n  if (typeof signRequests === 'number' && typeof timeout === 'undefined') {\n    timeout = signRequests;\n    signRequests = null;\n  }\n\n  if (!signRequests) signRequests = [];\n  return deferPromise(Promise, getBackend(Promise).then(function (backend) {\n    _ensureSupport(backend);\n\n    var native = backend.native;\n    var u2f = backend.u2f;\n    return new Promise(function (resolve, reject) {\n      function cbNative(response) {\n        if (response.errorCode) reject(makeError(\"Registration failed\", response));else {\n          delete response.errorCode;\n          resolve(response);\n        }\n      }\n\n      function cbChrome(err, response) {\n        if (err) reject(err);else if (response.errorCode) reject(makeError(\"Registration failed\", response));else resolve(response);\n      }\n\n      if (native) {\n        var appId = registerRequests[0].appId;\n        u2f.register(appId, registerRequests, signRequests, cbNative, timeout);\n      } else {\n        u2f.register(registerRequests, signRequests, cbChrome, timeout);\n      }\n    });\n  })).promise;\n}\n\nfunction sign(signRequests, timeout) {\n  var Promise = this;\n  if (!Array.isArray(signRequests)) signRequests = [signRequests];\n  return deferPromise(Promise, getBackend(Promise).then(function (backend) {\n    _ensureSupport(backend);\n\n    var native = backend.native;\n    var u2f = backend.u2f;\n    return new Promise(function (resolve, reject) {\n      function cbNative(response) {\n        if (response.errorCode) reject(makeError(\"Sign failed\", response));else {\n          delete response.errorCode;\n          resolve(response);\n        }\n      }\n\n      function cbChrome(err, response) {\n        if (err) reject(err);else if (response.errorCode) reject(makeError(\"Sign failed\", response));else resolve(response);\n      }\n\n      if (native) {\n        var appId = signRequests[0].appId;\n        var challenge = signRequests[0].challenge;\n        u2f.sign(appId, challenge, signRequests, cbNative, timeout);\n      } else {\n        u2f.sign(signRequests, cbChrome, timeout);\n      }\n    });\n  })).promise;\n}\n\nfunction makeDefault(func) {\n  API[func] = function () {\n    if (!global.Promise) // This is very unlikely to ever happen, since browsers\n      // supporting U2F will most likely support Promises.\n      throw new Error(\"The platform doesn't natively support promises\");\n    var args = [].slice.call(arguments);\n    return API(global.Promise)[func].apply(null, args);\n  };\n} // Provide default functions using the built-in Promise if available.\n\n\nmakeDefault('isSupported');\nmakeDefault('ensureSupport');\nmakeDefault('register');\nmakeDefault('sign');","// Copyright 2014 Google Inc. All rights reserved\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n/** Namespace for the U2F api.\n * @type {Object}\n */\n\nvar u2f = u2f || {};\nmodule.exports = u2f; // Adaptation for u2f-api package\n\n/**\n * The U2F extension id\n * @type {string}\n * @const\n */\n\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\n\nu2f.MessageTypes = {\n  'U2F_REGISTER_REQUEST': 'u2f_register_request',\n  'U2F_SIGN_REQUEST': 'u2f_sign_request',\n  'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n  'U2F_SIGN_RESPONSE': 'u2f_sign_response'\n};\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\n\nu2f.ErrorCodes = {\n  'OK': 0,\n  'OTHER_ERROR': 1,\n  'BAD_REQUEST': 2,\n  'CONFIGURATION_UNSUPPORTED': 3,\n  'DEVICE_INELIGIBLE': 4,\n  'TIMEOUT': 5\n};\n/**\n * A message type for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   signRequests: Array.<u2f.SignRequest>,\n *   registerRequests: ?Array.<u2f.RegisterRequest>,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\n\nu2f.Request;\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\n\nu2f.Response;\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\n\nu2f.Error;\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\n\nu2f.SignRequest;\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\n\nu2f.SignResponse;\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   appId: string\n * }}\n */\n\nu2f.RegisterRequest;\n/**\n * Data object for a registration response.\n * @typedef {{\n *   registrationData: string,\n *   clientData: string\n * }}\n */\n\nu2f.RegisterResponse; // Low level MessagePort API support\n\n/**\n * Call MessagePort disconnect\n */\n\nu2f.disconnect = function () {\n  if (u2f.port_ && u2f.port_.port_) {\n    u2f.port_.port_.disconnect();\n    u2f.port_ = null;\n  }\n};\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\n\n\nu2f.getMessagePort = function (callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function () {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n/**\n * Connects directly to the extension via chrome.runtime.connect\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\n\n\nu2f.getChromeRuntimePort_ = function (callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID, {\n    'includeTlsChannelId': true\n  });\n  setTimeout(function () {\n    callback(null, new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\n\n\nu2f.WrappedChromeRuntimePort_ = function (port) {\n  this.port_ = port;\n};\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\n\n\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function (message) {\n  this.port_.postMessage(message);\n};\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\n\n\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener = function (eventName, handler) {\n  var name = eventName.toLowerCase();\n\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function (message) {\n      // Emulate a minimal MessageEvent object\n      handler({\n        'data': message\n      });\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\n\n\nu2f.getIframePort_ = function (callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n  var hasCalledBack = false;\n  var channel = new MessageChannel();\n\n  var ready = function ready(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n\n      if (!hasCalledBack) {\n        hasCalledBack = true;\n        callback(null, channel.port1);\n      }\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n  iframe.addEventListener('load', function () {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  }); // Give this 200ms to initialize, after that, we treat this method as failed\n\n  setTimeout(function () {\n    if (!hasCalledBack) {\n      hasCalledBack = true;\n      callback(new Error(\"IFrame extension not supported\"));\n    }\n  }, 200);\n}; // High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\n\n\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\n\nu2f.port_ = null;\n/**\n * Callbacks waiting for a port\n * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\n\nu2f.waitingForPort_ = [];\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\n\nu2f.reqCounter_ = 0;\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\n\nu2f.callbackMap_ = {};\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\n\nu2f.getPortSingleton_ = function (callback) {\n  if (u2f.port_) {\n    callback(null, u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function (err, port) {\n        if (!err) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n          /** @type {function(Event)} */\n          u2f.responseHandler_);\n        } // Careful, here be async callbacks. Maybe.\n\n\n        while (u2f.waitingForPort_.length) {\n          u2f.waitingForPort_.shift()(err, port);\n        }\n      });\n    }\n\n    u2f.waitingForPort_.push(callback);\n  }\n};\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\n\n\nu2f.responseHandler_ = function (message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(null, response['responseData']);\n};\n/**\n * Calls the callback with true or false as first and only argument\n * @param {Function} callback\n */\n\n\nu2f.isSupported = function (callback) {\n  u2f.getPortSingleton_(function (err, port) {\n    callback(!err);\n  });\n};\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\n\n\nu2f.sign = function (signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function (err, port) {\n    if (err) return callback(err);\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {Array.<u2f.RegisterRequest>} registerRequests\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\n\n\nu2f.register = function (registerRequests, signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function (err, port) {\n    if (err) return callback(err);\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};"],"sourceRoot":""}