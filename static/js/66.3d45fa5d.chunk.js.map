{"version":3,"sources":["../../onboard/node_modules/base-x/src/index.js","../../onboard/node_modules/bs58/index.js","../../onboard/node_modules/bs58check/index.js","../../onboard/node_modules/bs58check/base.js","../../onboard/node_modules/hdkey/lib/hdkey.js","../../onboard/node_modules/hdkey/node_modules/secp256k1/elliptic.js","../../onboard/node_modules/hdkey/node_modules/secp256k1/lib/index.js","../../onboard/node_modules/hdkey/node_modules/secp256k1/lib/elliptic.js"],"names":["_Buffer","Buffer","module","exports","ALPHABET","length","TypeError","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","alloc","psz","zeroes","size","b256","carry","it3","Error","it4","vch","allocUnsafe","fill","encode","Array","isArray","from","isBuffer","pbegin","pend","b58","it1","it2","str","repeat","decode","string","buffer","basex","createHash","bs58checkBase","tmp","update","digest","base58","checksumFn","decodeRaw","payload","slice","checksum","newChecksum","concat","assert","crypto","bs58check","secp256k1","MASTER_SECRET","BITCOIN_VERSIONS","private","public","HDKey","versions","this","depth","index","_privateKey","_publicKey","chainCode","_fingerprint","parentFingerprint","serialize","hdkey","version","key","writeUInt32BE","writeUInt8","fingerprint","copy","hash160","buf","sha","Object","defineProperty","prototype","get","_identifier","identifier","set","value","equal","privateKeyVerify","publicKeyCreate","publicKey","readUInt32BE","publicKeyVerify","publicKeyConvert","privateKey","derive","path","entries","split","forEach","c","hardened","childIndex","parseInt","deriveChild","test","data","isHardened","indexBuffer","pk","zb","I","createHmac","IL","IR","hd","privateKeyTweakAdd","err","publicKeyTweakAdd","sign","hash","ecdsaSign","signature","verify","ecdsaVerify","wipePrivateData","randomBytes","toJSON","xpriv","privateExtendedKey","xpub","publicExtendedKey","fromMasterSeed","seedBuffer","fromExtendedKey","base58key","keyBuffer","readUInt8","fromJSON","obj","HARDENED_OFFSET","_createForOfIteratorHelper","errors","cond","msg","isUint8Array","name","undefined","numbers","join","includes","_msg","isCompressed","toTypeString","getAssertedOutput","output","arguments","len","toString","call","contextRandomize","seed","seckey","privateKeyNegate","tweak","privateKeyTweakMul","pubkey","compressed","publicKeyNegate","publicKeyCombine","pubkeys","_step","_iterator","s","n","done","e","f","publicKeyTweakMul","signatureNormalize","sig","signatureExport","outputlen","signatureImport","msg32","options","noncefn","recid","ecdsaRecover","ecdh","hashfn","xbuf","ybuf","ec","EC","ecparams","curve","BN","constructor","loadPublicKey","first","cmp","p","y","toRed","red","redSqr","redIMul","redIAdd","b","redSqrt","isOdd","redNeg","keyPair","pub","loadCompressedPublicKey","subarray","x3","redISub","isZero","loadUncompressedPublicKey","savePublicKey","point","bn","negate","sub","umod","toArrayLike","iadd","isub","tweaked","imul","keyFromPrivate","getPublic","pair","pairs","_i","add","isInfinity","g","mul","r","nh","sigR","sigS","lenR","posR","lenS","posS","message","_noncefn","counter","nonce","d","canonical","k","pers","recoveryParam","sigObj","sigr","sigs","recoverPubKey","scalar","_data","sha256","getX","toArray","_i2","getY","_i3"],"mappings":"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","file":"static/js/66.3d45fa5d.chunk.js","sourcesContent":["'use strict'; // base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\n\nvar _Buffer = require('safe-buffer').Buffer;\n\nfunction base(ALPHABET) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n\n  var BASE_MAP = new Uint8Array(256);\n\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n\n    BASE_MAP[xc] = i;\n  }\n\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n\n  function encode(source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) {\n      source = _Buffer.from(source);\n    }\n\n    if (!_Buffer.isBuffer(source)) {\n      throw new TypeError('Expected Buffer');\n    }\n\n    if (source.length === 0) {\n      return '';\n    } // Skip & count leading zeroes.\n\n\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    } // Allocate enough space in big-endian base58 representation.\n\n\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size); // Process the bytes.\n\n    while (pbegin !== pend) {\n      var carry = source[pbegin]; // Apply \"b58 = b58 * 256 + ch\".\n\n      var i = 0;\n\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n\n      length = i;\n      pbegin++;\n    } // Skip leading zeroes in base58 result.\n\n\n    var it2 = size - length;\n\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    } // Translate the result into a string.\n\n\n    var str = LEADER.repeat(zeroes);\n\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n\n    return str;\n  }\n\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n\n    if (source.length === 0) {\n      return _Buffer.alloc(0);\n    }\n\n    var psz = 0; // Skip leading spaces.\n\n    if (source[psz] === ' ') {\n      return;\n    } // Skip and count leading '1's.\n\n\n    var zeroes = 0;\n    var length = 0;\n\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    } // Allocate enough space in big-endian base256 representation.\n\n\n    var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n\n    var b256 = new Uint8Array(size); // Process the characters.\n\n    while (source[psz]) {\n      // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]; // Invalid character\n\n      if (carry === 255) {\n        return;\n      }\n\n      var i = 0;\n\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n\n      length = i;\n      psz++;\n    } // Skip trailing spaces.\n\n\n    if (source[psz] === ' ') {\n      return;\n    } // Skip leading zeroes in b256.\n\n\n    var it4 = size - length;\n\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));\n\n    vch.fill(0x00, 0, zeroes);\n    var j = zeroes;\n\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n\n    return vch;\n  }\n\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n\n    if (buffer) {\n      return buffer;\n    }\n\n    throw new Error('Non-base' + BASE + ' character');\n  }\n\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\n\nmodule.exports = base;","var basex = require('base-x');\n\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nmodule.exports = basex(ALPHABET);","'use strict';\n\nvar createHash = require('create-hash');\n\nvar bs58checkBase = require('./base'); // SHA256(SHA256(buffer))\n\n\nfunction sha256x2(buffer) {\n  var tmp = createHash('sha256').update(buffer).digest();\n  return createHash('sha256').update(tmp).digest();\n}\n\nmodule.exports = bs58checkBase(sha256x2);","'use strict';\n\nvar base58 = require('bs58');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode(payload) {\n    var checksum = checksumFn(payload);\n    return base58.encode(Buffer.concat([payload, checksum], payload.length + 4));\n  }\n\n  function decodeRaw(buffer) {\n    var payload = buffer.slice(0, -4);\n    var checksum = buffer.slice(-4);\n    var newChecksum = checksumFn(payload);\n    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;\n    return payload;\n  } // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n\n\n  function decodeUnsafe(string) {\n    var buffer = base58.decodeUnsafe(string);\n    if (!buffer) return;\n    return decodeRaw(buffer);\n  }\n\n  function decode(string) {\n    var buffer = base58.decode(string);\n    var payload = decodeRaw(buffer, checksumFn);\n    if (!payload) throw new Error('Invalid checksum');\n    return payload;\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  };\n};","var assert = require('assert');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar crypto = require('crypto');\n\nvar bs58check = require('bs58check');\n\nvar secp256k1 = require('secp256k1');\n\nvar MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\nvar HARDENED_OFFSET = 0x80000000;\nvar LEN = 78; // Bitcoin hardcoded by default, can use package `coininfo` for others\n\nvar BITCOIN_VERSIONS = {\n  private: 0x0488ADE4,\n  public: 0x0488B21E\n};\n\nfunction HDKey(versions) {\n  this.versions = versions || BITCOIN_VERSIONS;\n  this.depth = 0;\n  this.index = 0;\n  this._privateKey = null;\n  this._publicKey = null;\n  this.chainCode = null;\n  this._fingerprint = 0;\n  this.parentFingerprint = 0;\n}\n\nObject.defineProperty(HDKey.prototype, 'fingerprint', {\n  get: function get() {\n    return this._fingerprint;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'identifier', {\n  get: function get() {\n    return this._identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'pubKeyHash', {\n  get: function get() {\n    return this.identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateKey', {\n  get: function get() {\n    return this._privateKey;\n  },\n  set: function set(value) {\n    assert.equal(value.length, 32, 'Private key must be 32 bytes.');\n    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key');\n    this._privateKey = value;\n    this._publicKey = Buffer.from(secp256k1.publicKeyCreate(value, true));\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicKey', {\n  get: function get() {\n    return this._publicKey;\n  },\n  set: function set(value) {\n    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.');\n    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key');\n    this._publicKey = Buffer.from(secp256k1.publicKeyConvert(value, true)); // force compressed point\n\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n    this._privateKey = null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateExtendedKey', {\n  get: function get() {\n    if (this._privateKey) return bs58check.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])));else return null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicExtendedKey', {\n  get: function get() {\n    return bs58check.encode(serialize(this, this.versions.public, this.publicKey));\n  }\n});\n\nHDKey.prototype.derive = function (path) {\n  if (path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return this;\n  }\n\n  var entries = path.split('/');\n  var hdkey = this;\n  entries.forEach(function (c, i) {\n    if (i === 0) {\n      assert(/^[mM]{1}/.test(c), 'Path must start with \"m\" or \"M\"');\n      return;\n    }\n\n    var hardened = c.length > 1 && c[c.length - 1] === \"'\";\n    var childIndex = parseInt(c, 10); // & (HARDENED_OFFSET - 1)\n\n    assert(childIndex < HARDENED_OFFSET, 'Invalid index');\n    if (hardened) childIndex += HARDENED_OFFSET;\n    hdkey = hdkey.deriveChild(childIndex);\n  });\n  return hdkey;\n};\n\nHDKey.prototype.deriveChild = function (index) {\n  var isHardened = index >= HARDENED_OFFSET;\n  var indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  var data;\n\n  if (isHardened) {\n    // Hardened child\n    assert(this.privateKey, 'Could not derive hardened child key');\n    var pk = this.privateKey;\n    var zb = Buffer.alloc(1, 0);\n    pk = Buffer.concat([zb, pk]); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data = Buffer.concat([pk, indexBuffer]);\n  } else {\n    // Normal child\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data = Buffer.concat([this.publicKey, indexBuffer]);\n  }\n\n  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hd = new HDKey(this.versions); // Private parent key -> private child key\n\n  if (this.privateKey) {\n    // ki = parse256(IL) + kpar (mod n)\n    try {\n      hd.privateKey = Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(this.privateKey), IL)); // throw if IL >= n || (privateKey + IL) === 0\n    } catch (err) {\n      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    } // Public parent key -> public child key\n\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    try {\n      hd.publicKey = Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true)); // throw if IL >= n || (g**IL + publicKey) is infinity\n    } catch (err) {\n      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  hd.chainCode = IR;\n  hd.depth = this.depth + 1;\n  hd.parentFingerprint = this.fingerprint; // .readUInt32BE(0)\n\n  hd.index = index;\n  return hd;\n};\n\nHDKey.prototype.sign = function (hash) {\n  return Buffer.from(secp256k1.ecdsaSign(hash, this.privateKey).signature);\n};\n\nHDKey.prototype.verify = function (hash, signature) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(hash), Uint8Array.from(this.publicKey));\n};\n\nHDKey.prototype.wipePrivateData = function () {\n  if (this._privateKey) crypto.randomBytes(this._privateKey.length).copy(this._privateKey);\n  this._privateKey = null;\n  return this;\n};\n\nHDKey.prototype.toJSON = function () {\n  return {\n    xpriv: this.privateExtendedKey,\n    xpub: this.publicExtendedKey\n  };\n};\n\nHDKey.fromMasterSeed = function (seedBuffer, versions) {\n  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hdkey = new HDKey(versions);\n  hdkey.chainCode = IR;\n  hdkey.privateKey = IL;\n  return hdkey;\n};\n\nHDKey.fromExtendedKey = function (base58key, versions) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  versions = versions || BITCOIN_VERSIONS;\n  var hdkey = new HDKey(versions);\n  var keyBuffer = bs58check.decode(base58key);\n  var version = keyBuffer.readUInt32BE(0);\n  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public');\n  hdkey.depth = keyBuffer.readUInt8(4);\n  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5);\n  hdkey.index = keyBuffer.readUInt32BE(9);\n  hdkey.chainCode = keyBuffer.slice(13, 45);\n  var key = keyBuffer.slice(45);\n\n  if (key.readUInt8(0) === 0) {\n    // private\n    assert(version === versions.private, 'Version mismatch: version does not match private');\n    hdkey.privateKey = key.slice(1); // cut off first 0x0 byte\n  } else {\n    assert(version === versions.public, 'Version mismatch: version does not match public');\n    hdkey.publicKey = key;\n  }\n\n  return hdkey;\n};\n\nHDKey.fromJSON = function (obj) {\n  return HDKey.fromExtendedKey(obj.xpriv);\n};\n\nfunction serialize(hdkey, version, key) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  var buffer = Buffer.allocUnsafe(LEN);\n  buffer.writeUInt32BE(version, 0);\n  buffer.writeUInt8(hdkey.depth, 4);\n  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000;\n  buffer.writeUInt32BE(fingerprint, 5);\n  buffer.writeUInt32BE(hdkey.index, 9);\n  hdkey.chainCode.copy(buffer, 13);\n  key.copy(buffer, 45);\n  return buffer;\n}\n\nfunction hash160(buf) {\n  var sha = crypto.createHash('sha256').update(buf).digest();\n  return crypto.createHash('ripemd160').update(sha).digest();\n}\n\nHDKey.HARDENED_OFFSET = HARDENED_OFFSET;\nmodule.exports = HDKey;","module.exports = require('./lib')(require('./lib/elliptic'));","var _createForOfIteratorHelper = require(\"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n};\n\nfunction assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\n\nfunction isUint8Array(name, value, length) {\n  assert(value instanceof Uint8Array, \"Expected \".concat(name, \" to be an Uint8Array\"));\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      var numbers = length.join(', ');\n      var msg = \"Expected \".concat(name, \" to be an Uint8Array with length [\").concat(numbers, \"]\");\n      assert(length.includes(value.length), msg);\n    } else {\n      var _msg = \"Expected \".concat(name, \" to be an Uint8Array with length \").concat(length);\n\n      assert(value.length === length, _msg);\n    }\n  }\n}\n\nfunction isCompressed(value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');\n}\n\nfunction getAssertedOutput() {\n  var output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (len) {\n    return new Uint8Array(len);\n  };\n  var length = arguments.length > 1 ? arguments[1] : undefined;\n  if (typeof output === 'function') output = output(length);\n  isUint8Array('output', output, length);\n  return output;\n}\n\nfunction toTypeString(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nmodule.exports = function (secp256k1) {\n  return {\n    contextRandomize: function contextRandomize(seed) {\n      assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');\n      if (seed !== null) isUint8Array('seed', seed, 32);\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n      }\n    },\n    privateKeyVerify: function privateKeyVerify(seckey) {\n      isUint8Array('private key', seckey, 32);\n      return secp256k1.privateKeyVerify(seckey) === 0;\n    },\n    privateKeyNegate: function privateKeyNegate(seckey) {\n      isUint8Array('private key', seckey, 32);\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    publicKeyVerify: function publicKeyVerify(pubkey) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      return secp256k1.publicKeyVerify(pubkey) === 0;\n    },\n    publicKeyCreate: function publicKeyCreate(seckey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('private key', seckey, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SECKEY_INVALID);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyConvert: function publicKeyConvert(pubkey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyNegate: function publicKeyNegate(pubkey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyCombine: function publicKeyCombine(pubkeys) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');\n\n      var _iterator = _createForOfIteratorHelper(pubkeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pubkey = _step.value;\n          isUint8Array('public key', pubkey, [33, 65]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyTweakAdd: function publicKeyTweakAdd(pubkey, tweak) {\n      var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    publicKeyTweakMul: function publicKeyTweakMul(pubkey, tweak) {\n      var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    signatureNormalize: function signatureNormalize(sig) {\n      isUint8Array('signature', sig, 64);\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n      }\n    },\n    signatureExport: function signatureExport(sig, output) {\n      isUint8Array('signature', sig, 64);\n      output = getAssertedOutput(output, 72);\n      var obj = {\n        output: output,\n        outputlen: 72\n      };\n\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen);\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    signatureImport: function signatureImport(sig, output) {\n      isUint8Array('signature', sig);\n      output = getAssertedOutput(output, 64);\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaSign: function ecdsaSign(msg32, seckey) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('message', msg32, 32);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');\n      output = getAssertedOutput(output, 64);\n      var obj = {\n        signature: output,\n        recid: null\n      };\n\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj;\n\n        case 1:\n          throw new Error(errors.SIGN);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64);\n      isUint8Array('message', msg32, 32);\n      isUint8Array('public key', pubkey, [33, 65]);\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true;\n\n        case 3:\n          return false;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE);\n      }\n    },\n    ecdsaRecover: function ecdsaRecover(sig, recid, msg32) {\n      var compressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var output = arguments.length > 4 ? arguments[4] : undefined;\n      isUint8Array('signature', sig, 64);\n      assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');\n      isUint8Array('message', msg32, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.RECOVER);\n\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdh: function ecdh(pubkey, seckey) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);\n        isUint8Array('output', output);\n      } else {\n        output = getAssertedOutput(output, 32);\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.ECDH);\n      }\n    }\n  };\n};","var EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve; // Hack, we can not use bn.js@5, while elliptic uses bn.js@4\n// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758\n\nvar BN = ecparams.n.constructor;\n\nfunction loadCompressedPublicKey(first, xbuf) {\n  var x = new BN(xbuf); // overflow\n\n  if (x.cmp(ecparams.p) >= 0) return null;\n  x = x.toRed(ecparams.red); // compute corresponding Y\n\n  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();\n  if (first === 0x03 !== y.isOdd()) y = y.redNeg();\n  return ec.keyPair({\n    pub: {\n      x: x,\n      y: y\n    }\n  });\n}\n\nfunction loadUncompressedPublicKey(first, xbuf, ybuf) {\n  var x = new BN(xbuf);\n  var y = new BN(ybuf); // overflow\n\n  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;\n  x = x.toRed(ecparams.red);\n  y = y.toRed(ecparams.red); // is odd flag\n\n  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null; // x*x*x + b = y*y\n\n  var x3 = x.redSqr().redIMul(x);\n  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;\n  return ec.keyPair({\n    pub: {\n      x: x,\n      y: y\n    }\n  });\n}\n\nfunction loadPublicKey(pubkey) {\n  // length should be validated in interface\n  var first = pubkey[0];\n\n  switch (first) {\n    case 0x02:\n    case 0x03:\n      if (pubkey.length !== 33) return null;\n      return loadCompressedPublicKey(first, pubkey.subarray(1, 33));\n\n    case 0x04:\n    case 0x06:\n    case 0x07:\n      if (pubkey.length !== 65) return null;\n      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));\n\n    default:\n      return null;\n  }\n}\n\nfunction savePublicKey(output, point) {\n  var pubkey = point.encode(null, output.length === 33); // Loop should be faster because we do not need create extra Uint8Array\n  // output.set(new Uint8Array(pubkey))\n\n  for (var i = 0; i < output.length; ++i) {\n    output[i] = pubkey[i];\n  }\n}\n\nmodule.exports = {\n  contextRandomize: function contextRandomize() {\n    return 0;\n  },\n  privateKeyVerify: function privateKeyVerify(seckey) {\n    var bn = new BN(seckey);\n    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;\n  },\n  privateKeyNegate: function privateKeyNegate(seckey) {\n    var bn = new BN(seckey);\n    var negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(negate);\n    return 0;\n  },\n  privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {\n    var bn = new BN(tweak);\n    if (bn.cmp(ecparams.n) >= 0) return 1;\n    bn.iadd(new BN(seckey));\n    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);\n    if (bn.isZero()) return 1;\n    var tweaked = bn.toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(tweaked);\n    return 0;\n  },\n  privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {\n    var bn = new BN(tweak);\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n    bn.imul(new BN(seckey));\n    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);\n    var tweaked = bn.toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(tweaked);\n    return 0;\n  },\n  publicKeyVerify: function publicKeyVerify(pubkey) {\n    var pair = loadPublicKey(pubkey);\n    return pair === null ? 1 : 0;\n  },\n  publicKeyCreate: function publicKeyCreate(output, seckey) {\n    var bn = new BN(seckey);\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n    var point = ec.keyFromPrivate(seckey).getPublic();\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyConvert: function publicKeyConvert(output, pubkey) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    var point = pair.getPublic();\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyNegate: function publicKeyNegate(output, pubkey) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    var point = pair.getPublic();\n    point.y = point.y.redNeg();\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyCombine: function publicKeyCombine(output, pubkeys) {\n    var pairs = new Array(pubkeys.length);\n\n    for (var i = 0; i < pubkeys.length; ++i) {\n      pairs[i] = loadPublicKey(pubkeys[i]);\n      if (pairs[i] === null) return 1;\n    }\n\n    var point = pairs[0].getPublic();\n\n    for (var _i = 1; _i < pairs.length; ++_i) {\n      point = point.add(pairs[_i].pub);\n    }\n\n    if (point.isInfinity()) return 2;\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyTweakAdd: function publicKeyTweakAdd(output, pubkey, tweak) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    tweak = new BN(tweak);\n    if (tweak.cmp(ecparams.n) >= 0) return 2;\n    var point = pair.getPublic().add(ecparams.g.mul(tweak));\n    if (point.isInfinity()) return 2;\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyTweakMul: function publicKeyTweakMul(output, pubkey, tweak) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    tweak = new BN(tweak);\n    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;\n    var point = pair.getPublic().mul(tweak);\n    savePublicKey(output, point);\n    return 0;\n  },\n  signatureNormalize: function signatureNormalize(sig) {\n    var r = new BN(sig.subarray(0, 32));\n    var s = new BN(sig.subarray(32, 64));\n    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;\n\n    if (s.cmp(ec.nh) === 1) {\n      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);\n    }\n\n    return 0;\n  },\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureExport: function signatureExport(obj, sig) {\n    var sigR = sig.subarray(0, 32);\n    var sigS = sig.subarray(32, 64);\n    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;\n    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;\n    var output = obj.output; // Prepare R\n\n    var r = output.subarray(4, 4 + 33);\n    r[0] = 0x00;\n    r.set(sigR, 1);\n    var lenR = 33;\n    var posR = 0;\n\n    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR) {\n      ;\n    }\n\n    r = r.subarray(posR);\n    if (r[0] & 0x80) return 1;\n    if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) return 1; // Prepare S\n\n    var s = output.subarray(6 + 33, 6 + 33 + 33);\n    s[0] = 0x00;\n    s.set(sigS, 1);\n    var lenS = 33;\n    var posS = 0;\n\n    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS) {\n      ;\n    }\n\n    s = s.subarray(posS);\n    if (s[0] & 0x80) return 1;\n    if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) return 1; // Set output length for return\n\n    obj.outputlen = 6 + lenR + lenS; // Output in specified format\n    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n\n    output[0] = 0x30;\n    output[1] = obj.outputlen - 2;\n    output[2] = 0x02;\n    output[3] = r.length;\n    output.set(r, 4);\n    output[4 + lenR] = 0x02;\n    output[5 + lenR] = s.length;\n    output.set(s, 6 + lenR);\n    return 0;\n  },\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureImport: function signatureImport(output, sig) {\n    if (sig.length < 8) return 1;\n    if (sig.length > 72) return 1;\n    if (sig[0] !== 0x30) return 1;\n    if (sig[1] !== sig.length - 2) return 1;\n    if (sig[2] !== 0x02) return 1;\n    var lenR = sig[3];\n    if (lenR === 0) return 1;\n    if (5 + lenR >= sig.length) return 1;\n    if (sig[4 + lenR] !== 0x02) return 1;\n    var lenS = sig[5 + lenR];\n    if (lenS === 0) return 1;\n    if (6 + lenR + lenS !== sig.length) return 1;\n    if (sig[4] & 0x80) return 1;\n    if (lenR > 1 && sig[4] === 0x00 && !(sig[5] & 0x80)) return 1;\n    if (sig[lenR + 6] & 0x80) return 1;\n    if (lenS > 1 && sig[lenR + 6] === 0x00 && !(sig[lenR + 7] & 0x80)) return 1;\n    var sigR = sig.subarray(4, 4 + lenR);\n    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);\n    if (sigR.length > 32) return 1;\n    var sigS = sig.subarray(6 + lenR);\n    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);\n    if (sigS.length > 32) throw new Error('S length is too long');\n    var r = new BN(sigR);\n    if (r.cmp(ecparams.n) >= 0) r = new BN(0);\n    var s = new BN(sig.subarray(6 + lenR));\n    if (s.cmp(ecparams.n) >= 0) s = new BN(0);\n    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);\n    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);\n    return 0;\n  },\n  ecdsaSign: function ecdsaSign(obj, message, seckey, data, noncefn) {\n    if (noncefn) {\n      var _noncefn = noncefn;\n\n      noncefn = function noncefn(counter) {\n        var nonce = _noncefn(message, seckey, null, data, counter);\n\n        var isValid = nonce instanceof Uint8Array && nonce.length === 32;\n        if (!isValid) throw new Error('This is the way');\n        return new BN(nonce);\n      };\n    }\n\n    var d = new BN(seckey);\n    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;\n    var sig;\n\n    try {\n      sig = ec.sign(message, seckey, {\n        canonical: true,\n        k: noncefn,\n        pers: data\n      });\n    } catch (err) {\n      return 1;\n    }\n\n    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0);\n    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32);\n    obj.recid = sig.recoveryParam;\n    return 0;\n  },\n  ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {\n    var sigObj = {\n      r: sig.subarray(0, 32),\n      s: sig.subarray(32, 64)\n    };\n    var sigr = new BN(sigObj.r);\n    var sigs = new BN(sigObj.s);\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 2;\n    var point = pair.getPublic();\n    var isValid = ec.verify(msg32, sigObj, point);\n    return isValid ? 0 : 3;\n  },\n  ecdsaRecover: function ecdsaRecover(output, sig, recid, msg32) {\n    var sigObj = {\n      r: sig.slice(0, 32),\n      s: sig.slice(32, 64)\n    };\n    var sigr = new BN(sigObj.r);\n    var sigs = new BN(sigObj.s);\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n    if (sigr.isZero() || sigs.isZero()) return 2; // Can throw `throw new Error('Unable to find sencond key candinate');`\n\n    var point;\n\n    try {\n      point = ec.recoverPubKey(msg32, sigObj, recid);\n    } catch (err) {\n      return 2;\n    }\n\n    savePublicKey(output, point);\n    return 0;\n  },\n  ecdh: function ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    var scalar = new BN(seckey);\n    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;\n    var point = pair.getPublic().mul(scalar);\n\n    if (hashfn === undefined) {\n      var _data = point.encode(null, true);\n\n      var sha256 = ec.hash().update(_data).digest();\n\n      for (var i = 0; i < 32; ++i) {\n        output[i] = sha256[i];\n      }\n    } else {\n      if (!xbuf) xbuf = new Uint8Array(32);\n      var x = point.getX().toArray('be', 32);\n\n      for (var _i2 = 0; _i2 < 32; ++_i2) {\n        xbuf[_i2] = x[_i2];\n      }\n\n      if (!ybuf) ybuf = new Uint8Array(32);\n      var y = point.getY().toArray('be', 32);\n\n      for (var _i3 = 0; _i3 < 32; ++_i3) {\n        ybuf[_i3] = y[_i3];\n      }\n\n      var hash = hashfn(xbuf, ybuf, data);\n      var isValid = hash instanceof Uint8Array && hash.length === output.length;\n      if (!isValid) return 2;\n      output.set(hash);\n    }\n\n    return 0;\n  }\n};"],"sourceRoot":""}