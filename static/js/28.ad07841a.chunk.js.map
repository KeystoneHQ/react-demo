{"version":3,"sources":["../../onboard/dist/esm/hd-wallet-51018814.js","../../onboard/node_modules/bs58check/index.js","../../onboard/node_modules/bs58check/base.js","../../onboard/node_modules/hdkey/lib/hdkey.js"],"names":["publicToAddress","toChecksumAddress","generateAddresses","account","offset","publicKey","chainCode","path","hdk","addresses","i","dkey","deriveChild","address","toString","push","dPath","concat","isValidPath","parts","split","includes","undefined","accountFieldNumber","Number","slice","isNaN","changeFieldNumber","addressFieldNumber","createHash","bs58checkBase","module","exports","buffer","tmp","update","digest","base58","Buffer","checksumFn","decodeRaw","payload","checksum","newChecksum","encode","length","decode","string","Error","decodeUnsafe","assert","crypto","bs58check","secp256k1","MASTER_SECRET","from","BITCOIN_VERSIONS","private","public","HDKey","versions","this","depth","index","_privateKey","_publicKey","_fingerprint","parentFingerprint","serialize","hdkey","version","key","allocUnsafe","writeUInt32BE","writeUInt8","fingerprint","copy","hash160","buf","sha","Object","defineProperty","prototype","get","_identifier","identifier","set","value","equal","privateKeyVerify","publicKeyCreate","readUInt32BE","publicKeyVerify","publicKeyConvert","alloc","privateKey","derive","entries","forEach","c","hardened","childIndex","parseInt","test","data","isHardened","indexBuffer","pk","zb","I","createHmac","IL","IR","hd","privateKeyTweakAdd","err","publicKeyTweakAdd","sign","hash","ecdsaSign","signature","verify","ecdsaVerify","Uint8Array","wipePrivateData","randomBytes","toJSON","xpriv","privateExtendedKey","xpub","publicExtendedKey","fromMasterSeed","seedBuffer","fromExtendedKey","base58key","keyBuffer","readUInt8","fromJSON","obj","HARDENED_OFFSET"],"mappings":"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","file":"static/js/28.ad07841a.chunk.js","sourcesContent":["import * as ethUtil from 'ethereumjs-util';\nimport HDKey from 'hdkey';\nimport { Buffer } from 'buffer';\nvar publicToAddress = ethUtil.publicToAddress,\n    toChecksumAddress = ethUtil.toChecksumAddress;\nvar numberToGet = 5;\n\nfunction generateAddresses(account, offset) {\n  var publicKey = account.publicKey,\n      chainCode = account.chainCode,\n      path = account.path;\n  var hdk = new HDKey();\n  hdk.publicKey = new Buffer(publicKey, 'hex');\n  hdk.chainCode = new Buffer(chainCode, 'hex');\n  var addresses = [];\n\n  for (var i = offset; i < numberToGet + offset; i++) {\n    var dkey = hdk.deriveChild(i);\n    var address = publicToAddress(dkey.publicKey, true).toString('hex');\n    addresses.push({\n      dPath: \"\".concat(path, \"/\").concat(i),\n      address: toChecksumAddress(\"0x\".concat(address))\n    });\n  }\n\n  return addresses;\n}\n\nfunction isValidPath(path) {\n  var parts = path.split('/');\n\n  if (parts[0] !== 'm') {\n    return false;\n  }\n\n  if (parts[1] !== \"44'\") {\n    return false;\n  }\n\n  if (![\"60'\", \"1'\", \"73799'\", \"246'\"].includes(parts[2])) {\n    return false;\n  }\n\n  if (parts[3] === undefined || parts[3] === \"0'\") {\n    return true;\n  }\n\n  var accountFieldNumber = Number(parts[3].slice(0, -1));\n\n  if (isNaN(accountFieldNumber) || accountFieldNumber < 0 || parts[3].slice(-1) !== \"'\") {\n    return false;\n  }\n\n  if (parts[4] === undefined) {\n    return true;\n  }\n\n  var changeFieldNumber = Number(parts[4]);\n\n  if (isNaN(changeFieldNumber) || changeFieldNumber < 0) {\n    return false;\n  }\n\n  if (parts[5] === undefined) {\n    return true;\n  }\n\n  var addressFieldNumber = Number(parts[5]);\n\n  if (isNaN(addressFieldNumber) || addressFieldNumber < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport { generateAddresses, isValidPath };","'use strict';\n\nvar createHash = require('create-hash');\n\nvar bs58checkBase = require('./base'); // SHA256(SHA256(buffer))\n\n\nfunction sha256x2(buffer) {\n  var tmp = createHash('sha256').update(buffer).digest();\n  return createHash('sha256').update(tmp).digest();\n}\n\nmodule.exports = bs58checkBase(sha256x2);","'use strict';\n\nvar base58 = require('bs58');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode(payload) {\n    var checksum = checksumFn(payload);\n    return base58.encode(Buffer.concat([payload, checksum], payload.length + 4));\n  }\n\n  function decodeRaw(buffer) {\n    var payload = buffer.slice(0, -4);\n    var checksum = buffer.slice(-4);\n    var newChecksum = checksumFn(payload);\n    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;\n    return payload;\n  } // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n\n\n  function decodeUnsafe(string) {\n    var buffer = base58.decodeUnsafe(string);\n    if (!buffer) return;\n    return decodeRaw(buffer);\n  }\n\n  function decode(string) {\n    var buffer = base58.decode(string);\n    var payload = decodeRaw(buffer, checksumFn);\n    if (!payload) throw new Error('Invalid checksum');\n    return payload;\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  };\n};","var assert = require('assert');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar crypto = require('crypto');\n\nvar bs58check = require('bs58check');\n\nvar secp256k1 = require('secp256k1');\n\nvar MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\nvar HARDENED_OFFSET = 0x80000000;\nvar LEN = 78; // Bitcoin hardcoded by default, can use package `coininfo` for others\n\nvar BITCOIN_VERSIONS = {\n  private: 0x0488ADE4,\n  public: 0x0488B21E\n};\n\nfunction HDKey(versions) {\n  this.versions = versions || BITCOIN_VERSIONS;\n  this.depth = 0;\n  this.index = 0;\n  this._privateKey = null;\n  this._publicKey = null;\n  this.chainCode = null;\n  this._fingerprint = 0;\n  this.parentFingerprint = 0;\n}\n\nObject.defineProperty(HDKey.prototype, 'fingerprint', {\n  get: function get() {\n    return this._fingerprint;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'identifier', {\n  get: function get() {\n    return this._identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'pubKeyHash', {\n  get: function get() {\n    return this.identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateKey', {\n  get: function get() {\n    return this._privateKey;\n  },\n  set: function set(value) {\n    assert.equal(value.length, 32, 'Private key must be 32 bytes.');\n    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key');\n    this._privateKey = value;\n    this._publicKey = Buffer.from(secp256k1.publicKeyCreate(value, true));\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicKey', {\n  get: function get() {\n    return this._publicKey;\n  },\n  set: function set(value) {\n    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.');\n    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key');\n    this._publicKey = Buffer.from(secp256k1.publicKeyConvert(value, true)); // force compressed point\n\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n    this._privateKey = null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateExtendedKey', {\n  get: function get() {\n    if (this._privateKey) return bs58check.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])));else return null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicExtendedKey', {\n  get: function get() {\n    return bs58check.encode(serialize(this, this.versions.public, this.publicKey));\n  }\n});\n\nHDKey.prototype.derive = function (path) {\n  if (path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return this;\n  }\n\n  var entries = path.split('/');\n  var hdkey = this;\n  entries.forEach(function (c, i) {\n    if (i === 0) {\n      assert(/^[mM]{1}/.test(c), 'Path must start with \"m\" or \"M\"');\n      return;\n    }\n\n    var hardened = c.length > 1 && c[c.length - 1] === \"'\";\n    var childIndex = parseInt(c, 10); // & (HARDENED_OFFSET - 1)\n\n    assert(childIndex < HARDENED_OFFSET, 'Invalid index');\n    if (hardened) childIndex += HARDENED_OFFSET;\n    hdkey = hdkey.deriveChild(childIndex);\n  });\n  return hdkey;\n};\n\nHDKey.prototype.deriveChild = function (index) {\n  var isHardened = index >= HARDENED_OFFSET;\n  var indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  var data;\n\n  if (isHardened) {\n    // Hardened child\n    assert(this.privateKey, 'Could not derive hardened child key');\n    var pk = this.privateKey;\n    var zb = Buffer.alloc(1, 0);\n    pk = Buffer.concat([zb, pk]); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data = Buffer.concat([pk, indexBuffer]);\n  } else {\n    // Normal child\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data = Buffer.concat([this.publicKey, indexBuffer]);\n  }\n\n  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hd = new HDKey(this.versions); // Private parent key -> private child key\n\n  if (this.privateKey) {\n    // ki = parse256(IL) + kpar (mod n)\n    try {\n      hd.privateKey = Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(this.privateKey), IL)); // throw if IL >= n || (privateKey + IL) === 0\n    } catch (err) {\n      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    } // Public parent key -> public child key\n\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    try {\n      hd.publicKey = Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true)); // throw if IL >= n || (g**IL + publicKey) is infinity\n    } catch (err) {\n      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  hd.chainCode = IR;\n  hd.depth = this.depth + 1;\n  hd.parentFingerprint = this.fingerprint; // .readUInt32BE(0)\n\n  hd.index = index;\n  return hd;\n};\n\nHDKey.prototype.sign = function (hash) {\n  return Buffer.from(secp256k1.ecdsaSign(hash, this.privateKey).signature);\n};\n\nHDKey.prototype.verify = function (hash, signature) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(hash), Uint8Array.from(this.publicKey));\n};\n\nHDKey.prototype.wipePrivateData = function () {\n  if (this._privateKey) crypto.randomBytes(this._privateKey.length).copy(this._privateKey);\n  this._privateKey = null;\n  return this;\n};\n\nHDKey.prototype.toJSON = function () {\n  return {\n    xpriv: this.privateExtendedKey,\n    xpub: this.publicExtendedKey\n  };\n};\n\nHDKey.fromMasterSeed = function (seedBuffer, versions) {\n  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hdkey = new HDKey(versions);\n  hdkey.chainCode = IR;\n  hdkey.privateKey = IL;\n  return hdkey;\n};\n\nHDKey.fromExtendedKey = function (base58key, versions) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  versions = versions || BITCOIN_VERSIONS;\n  var hdkey = new HDKey(versions);\n  var keyBuffer = bs58check.decode(base58key);\n  var version = keyBuffer.readUInt32BE(0);\n  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public');\n  hdkey.depth = keyBuffer.readUInt8(4);\n  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5);\n  hdkey.index = keyBuffer.readUInt32BE(9);\n  hdkey.chainCode = keyBuffer.slice(13, 45);\n  var key = keyBuffer.slice(45);\n\n  if (key.readUInt8(0) === 0) {\n    // private\n    assert(version === versions.private, 'Version mismatch: version does not match private');\n    hdkey.privateKey = key.slice(1); // cut off first 0x0 byte\n  } else {\n    assert(version === versions.public, 'Version mismatch: version does not match public');\n    hdkey.publicKey = key;\n  }\n\n  return hdkey;\n};\n\nHDKey.fromJSON = function (obj) {\n  return HDKey.fromExtendedKey(obj.xpriv);\n};\n\nfunction serialize(hdkey, version, key) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  var buffer = Buffer.allocUnsafe(LEN);\n  buffer.writeUInt32BE(version, 0);\n  buffer.writeUInt8(hdkey.depth, 4);\n  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000;\n  buffer.writeUInt32BE(fingerprint, 5);\n  buffer.writeUInt32BE(hdkey.index, 9);\n  hdkey.chainCode.copy(buffer, 13);\n  key.copy(buffer, 45);\n  return buffer;\n}\n\nfunction hash160(buf) {\n  var sha = crypto.createHash('sha256').update(buf).digest();\n  return crypto.createHash('ripemd160').update(sha).digest();\n}\n\nHDKey.HARDENED_OFFSET = HARDENED_OFFSET;\nmodule.exports = HDKey;"],"sourceRoot":""}