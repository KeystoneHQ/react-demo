{"version":3,"sources":["../../onboard/dist/esm/hd-wallet-51018814.js","../../onboard/node_modules/base-x/src/index.js","../../onboard/node_modules/bs58/index.js","../../onboard/node_modules/bs58check/index.js","../../onboard/node_modules/bs58check/base.js","../../onboard/node_modules/hdkey/lib/hdkey.js"],"names":["publicToAddress","toChecksumAddress","generateAddresses","account","offset","publicKey","chainCode","path","hdk","addresses","i","dkey","deriveChild","address","toString","push","dPath","concat","isValidPath","parts","split","includes","undefined","accountFieldNumber","Number","slice","isNaN","changeFieldNumber","addressFieldNumber","_Buffer","Buffer","module","exports","ALPHABET","length","TypeError","BASE_MAP","Uint8Array","j","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","alloc","psz","zeroes","size","b256","carry","it3","Error","it4","vch","allocUnsafe","fill","encode","Array","isArray","from","isBuffer","pbegin","pend","b58","it1","it2","str","repeat","decode","string","buffer","basex","createHash","bs58checkBase","tmp","update","digest","base58","checksumFn","decodeRaw","payload","checksum","newChecksum","assert","crypto","bs58check","secp256k1","MASTER_SECRET","BITCOIN_VERSIONS","private","public","HDKey","versions","this","depth","index","_privateKey","_publicKey","_fingerprint","parentFingerprint","serialize","hdkey","version","key","writeUInt32BE","writeUInt8","fingerprint","copy","hash160","buf","sha","Object","defineProperty","prototype","get","_identifier","identifier","set","value","equal","privateKeyVerify","publicKeyCreate","readUInt32BE","publicKeyVerify","publicKeyConvert","privateKey","derive","entries","forEach","c","hardened","childIndex","parseInt","test","data","isHardened","indexBuffer","pk","zb","I","createHmac","IL","IR","hd","privateKeyTweakAdd","err","publicKeyTweakAdd","sign","hash","ecdsaSign","signature","verify","ecdsaVerify","wipePrivateData","randomBytes","toJSON","xpriv","privateExtendedKey","xpub","publicExtendedKey","fromMasterSeed","seedBuffer","fromExtendedKey","base58key","keyBuffer","readUInt8","fromJSON","obj","HARDENED_OFFSET"],"mappings":"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","file":"static/js/62.c3a6892a.chunk.js","sourcesContent":["import * as ethUtil from 'ethereumjs-util';\nimport HDKey from 'hdkey';\nimport { Buffer } from 'buffer';\nvar publicToAddress = ethUtil.publicToAddress,\n    toChecksumAddress = ethUtil.toChecksumAddress;\nvar numberToGet = 5;\n\nfunction generateAddresses(account, offset) {\n  var publicKey = account.publicKey,\n      chainCode = account.chainCode,\n      path = account.path;\n  var hdk = new HDKey();\n  hdk.publicKey = new Buffer(publicKey, 'hex');\n  hdk.chainCode = new Buffer(chainCode, 'hex');\n  var addresses = [];\n\n  for (var i = offset; i < numberToGet + offset; i++) {\n    var dkey = hdk.deriveChild(i);\n    var address = publicToAddress(dkey.publicKey, true).toString('hex');\n    addresses.push({\n      dPath: \"\".concat(path, \"/\").concat(i),\n      address: toChecksumAddress(\"0x\".concat(address))\n    });\n  }\n\n  return addresses;\n}\n\nfunction isValidPath(path) {\n  var parts = path.split('/');\n\n  if (parts[0] !== 'm') {\n    return false;\n  }\n\n  if (parts[1] !== \"44'\") {\n    return false;\n  }\n\n  if (![\"60'\", \"1'\", \"73799'\", \"246'\"].includes(parts[2])) {\n    return false;\n  }\n\n  if (parts[3] === undefined || parts[3] === \"0'\") {\n    return true;\n  }\n\n  var accountFieldNumber = Number(parts[3].slice(0, -1));\n\n  if (isNaN(accountFieldNumber) || accountFieldNumber < 0 || parts[3].slice(-1) !== \"'\") {\n    return false;\n  }\n\n  if (parts[4] === undefined) {\n    return true;\n  }\n\n  var changeFieldNumber = Number(parts[4]);\n\n  if (isNaN(changeFieldNumber) || changeFieldNumber < 0) {\n    return false;\n  }\n\n  if (parts[5] === undefined) {\n    return true;\n  }\n\n  var addressFieldNumber = Number(parts[5]);\n\n  if (isNaN(addressFieldNumber) || addressFieldNumber < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport { generateAddresses, isValidPath };","'use strict'; // base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\n\nvar _Buffer = require('safe-buffer').Buffer;\n\nfunction base(ALPHABET) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n\n  var BASE_MAP = new Uint8Array(256);\n\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n\n    BASE_MAP[xc] = i;\n  }\n\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n\n  function encode(source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) {\n      source = _Buffer.from(source);\n    }\n\n    if (!_Buffer.isBuffer(source)) {\n      throw new TypeError('Expected Buffer');\n    }\n\n    if (source.length === 0) {\n      return '';\n    } // Skip & count leading zeroes.\n\n\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    } // Allocate enough space in big-endian base58 representation.\n\n\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size); // Process the bytes.\n\n    while (pbegin !== pend) {\n      var carry = source[pbegin]; // Apply \"b58 = b58 * 256 + ch\".\n\n      var i = 0;\n\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n\n      length = i;\n      pbegin++;\n    } // Skip leading zeroes in base58 result.\n\n\n    var it2 = size - length;\n\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    } // Translate the result into a string.\n\n\n    var str = LEADER.repeat(zeroes);\n\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n\n    return str;\n  }\n\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n\n    if (source.length === 0) {\n      return _Buffer.alloc(0);\n    }\n\n    var psz = 0; // Skip leading spaces.\n\n    if (source[psz] === ' ') {\n      return;\n    } // Skip and count leading '1's.\n\n\n    var zeroes = 0;\n    var length = 0;\n\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    } // Allocate enough space in big-endian base256 representation.\n\n\n    var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n\n    var b256 = new Uint8Array(size); // Process the characters.\n\n    while (source[psz]) {\n      // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]; // Invalid character\n\n      if (carry === 255) {\n        return;\n      }\n\n      var i = 0;\n\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n\n      length = i;\n      psz++;\n    } // Skip trailing spaces.\n\n\n    if (source[psz] === ' ') {\n      return;\n    } // Skip leading zeroes in b256.\n\n\n    var it4 = size - length;\n\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));\n\n    vch.fill(0x00, 0, zeroes);\n    var j = zeroes;\n\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n\n    return vch;\n  }\n\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n\n    if (buffer) {\n      return buffer;\n    }\n\n    throw new Error('Non-base' + BASE + ' character');\n  }\n\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\n\nmodule.exports = base;","var basex = require('base-x');\n\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nmodule.exports = basex(ALPHABET);","'use strict';\n\nvar createHash = require('create-hash');\n\nvar bs58checkBase = require('./base'); // SHA256(SHA256(buffer))\n\n\nfunction sha256x2(buffer) {\n  var tmp = createHash('sha256').update(buffer).digest();\n  return createHash('sha256').update(tmp).digest();\n}\n\nmodule.exports = bs58checkBase(sha256x2);","'use strict';\n\nvar base58 = require('bs58');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode(payload) {\n    var checksum = checksumFn(payload);\n    return base58.encode(Buffer.concat([payload, checksum], payload.length + 4));\n  }\n\n  function decodeRaw(buffer) {\n    var payload = buffer.slice(0, -4);\n    var checksum = buffer.slice(-4);\n    var newChecksum = checksumFn(payload);\n    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;\n    return payload;\n  } // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n\n\n  function decodeUnsafe(string) {\n    var buffer = base58.decodeUnsafe(string);\n    if (!buffer) return;\n    return decodeRaw(buffer);\n  }\n\n  function decode(string) {\n    var buffer = base58.decode(string);\n    var payload = decodeRaw(buffer, checksumFn);\n    if (!payload) throw new Error('Invalid checksum');\n    return payload;\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  };\n};","var assert = require('assert');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar crypto = require('crypto');\n\nvar bs58check = require('bs58check');\n\nvar secp256k1 = require('secp256k1');\n\nvar MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\nvar HARDENED_OFFSET = 0x80000000;\nvar LEN = 78; // Bitcoin hardcoded by default, can use package `coininfo` for others\n\nvar BITCOIN_VERSIONS = {\n  private: 0x0488ADE4,\n  public: 0x0488B21E\n};\n\nfunction HDKey(versions) {\n  this.versions = versions || BITCOIN_VERSIONS;\n  this.depth = 0;\n  this.index = 0;\n  this._privateKey = null;\n  this._publicKey = null;\n  this.chainCode = null;\n  this._fingerprint = 0;\n  this.parentFingerprint = 0;\n}\n\nObject.defineProperty(HDKey.prototype, 'fingerprint', {\n  get: function get() {\n    return this._fingerprint;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'identifier', {\n  get: function get() {\n    return this._identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'pubKeyHash', {\n  get: function get() {\n    return this.identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateKey', {\n  get: function get() {\n    return this._privateKey;\n  },\n  set: function set(value) {\n    assert.equal(value.length, 32, 'Private key must be 32 bytes.');\n    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key');\n    this._privateKey = value;\n    this._publicKey = Buffer.from(secp256k1.publicKeyCreate(value, true));\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicKey', {\n  get: function get() {\n    return this._publicKey;\n  },\n  set: function set(value) {\n    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.');\n    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key');\n    this._publicKey = Buffer.from(secp256k1.publicKeyConvert(value, true)); // force compressed point\n\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n    this._privateKey = null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateExtendedKey', {\n  get: function get() {\n    if (this._privateKey) return bs58check.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])));else return null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicExtendedKey', {\n  get: function get() {\n    return bs58check.encode(serialize(this, this.versions.public, this.publicKey));\n  }\n});\n\nHDKey.prototype.derive = function (path) {\n  if (path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return this;\n  }\n\n  var entries = path.split('/');\n  var hdkey = this;\n  entries.forEach(function (c, i) {\n    if (i === 0) {\n      assert(/^[mM]{1}/.test(c), 'Path must start with \"m\" or \"M\"');\n      return;\n    }\n\n    var hardened = c.length > 1 && c[c.length - 1] === \"'\";\n    var childIndex = parseInt(c, 10); // & (HARDENED_OFFSET - 1)\n\n    assert(childIndex < HARDENED_OFFSET, 'Invalid index');\n    if (hardened) childIndex += HARDENED_OFFSET;\n    hdkey = hdkey.deriveChild(childIndex);\n  });\n  return hdkey;\n};\n\nHDKey.prototype.deriveChild = function (index) {\n  var isHardened = index >= HARDENED_OFFSET;\n  var indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  var data;\n\n  if (isHardened) {\n    // Hardened child\n    assert(this.privateKey, 'Could not derive hardened child key');\n    var pk = this.privateKey;\n    var zb = Buffer.alloc(1, 0);\n    pk = Buffer.concat([zb, pk]); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data = Buffer.concat([pk, indexBuffer]);\n  } else {\n    // Normal child\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data = Buffer.concat([this.publicKey, indexBuffer]);\n  }\n\n  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hd = new HDKey(this.versions); // Private parent key -> private child key\n\n  if (this.privateKey) {\n    // ki = parse256(IL) + kpar (mod n)\n    try {\n      hd.privateKey = Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(this.privateKey), IL)); // throw if IL >= n || (privateKey + IL) === 0\n    } catch (err) {\n      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    } // Public parent key -> public child key\n\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    try {\n      hd.publicKey = Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true)); // throw if IL >= n || (g**IL + publicKey) is infinity\n    } catch (err) {\n      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  hd.chainCode = IR;\n  hd.depth = this.depth + 1;\n  hd.parentFingerprint = this.fingerprint; // .readUInt32BE(0)\n\n  hd.index = index;\n  return hd;\n};\n\nHDKey.prototype.sign = function (hash) {\n  return Buffer.from(secp256k1.ecdsaSign(hash, this.privateKey).signature);\n};\n\nHDKey.prototype.verify = function (hash, signature) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(hash), Uint8Array.from(this.publicKey));\n};\n\nHDKey.prototype.wipePrivateData = function () {\n  if (this._privateKey) crypto.randomBytes(this._privateKey.length).copy(this._privateKey);\n  this._privateKey = null;\n  return this;\n};\n\nHDKey.prototype.toJSON = function () {\n  return {\n    xpriv: this.privateExtendedKey,\n    xpub: this.publicExtendedKey\n  };\n};\n\nHDKey.fromMasterSeed = function (seedBuffer, versions) {\n  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hdkey = new HDKey(versions);\n  hdkey.chainCode = IR;\n  hdkey.privateKey = IL;\n  return hdkey;\n};\n\nHDKey.fromExtendedKey = function (base58key, versions) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  versions = versions || BITCOIN_VERSIONS;\n  var hdkey = new HDKey(versions);\n  var keyBuffer = bs58check.decode(base58key);\n  var version = keyBuffer.readUInt32BE(0);\n  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public');\n  hdkey.depth = keyBuffer.readUInt8(4);\n  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5);\n  hdkey.index = keyBuffer.readUInt32BE(9);\n  hdkey.chainCode = keyBuffer.slice(13, 45);\n  var key = keyBuffer.slice(45);\n\n  if (key.readUInt8(0) === 0) {\n    // private\n    assert(version === versions.private, 'Version mismatch: version does not match private');\n    hdkey.privateKey = key.slice(1); // cut off first 0x0 byte\n  } else {\n    assert(version === versions.public, 'Version mismatch: version does not match public');\n    hdkey.publicKey = key;\n  }\n\n  return hdkey;\n};\n\nHDKey.fromJSON = function (obj) {\n  return HDKey.fromExtendedKey(obj.xpriv);\n};\n\nfunction serialize(hdkey, version, key) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  var buffer = Buffer.allocUnsafe(LEN);\n  buffer.writeUInt32BE(version, 0);\n  buffer.writeUInt8(hdkey.depth, 4);\n  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000;\n  buffer.writeUInt32BE(fingerprint, 5);\n  buffer.writeUInt32BE(hdkey.index, 9);\n  hdkey.chainCode.copy(buffer, 13);\n  key.copy(buffer, 45);\n  return buffer;\n}\n\nfunction hash160(buf) {\n  var sha = crypto.createHash('sha256').update(buf).digest();\n  return crypto.createHash('ripemd160').update(sha).digest();\n}\n\nHDKey.HARDENED_OFFSET = HARDENED_OFFSET;\nmodule.exports = HDKey;"],"sourceRoot":""}