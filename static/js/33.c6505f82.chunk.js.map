{"version":3,"sources":["../node_modules/u2f-api/index.js","../node_modules/u2f-api/lib/u2f-api.js","../node_modules/u2f-api/lib/google-u2f-api.js","../node_modules/@ledgerhq/hw-transport-u2f/lib-es/TransportU2F.js"],"names":["module","exports","API","chromeApi","isBrowser","navigator","userAgent","isSafari","match","isEDGE","_backend","getBackend","Promise","resolve","reject","notSupported","u2f","native","window","sign","location","protocol","MessageChannel","isSupported","ok","bind","ensureSupport","register","ErrorCodes","ErrorNames","makeError","msg","err","code","errorCode","type","error","Error","metaData","deferPromise","promise","ret","then","cancel","disconnect","backend","this","_ensureSupport","registerRequests","signRequests","timeout","Array","isArray","appId","response","challenge","makeDefault","func","global","args","slice","call","arguments","apply","CANCELLED","OK","OTHER_ERROR","BAD_REQUEST","CONFIGURATION_UNSUPPORTED","DEVICE_INELIGIBLE","TIMEOUT","EXTENSION_ID","MessageTypes","Request","Response","SignRequest","SignResponse","RegisterRequest","RegisterResponse","port_","getMessagePort","callback","chrome","runtime","U2F_SIGN_REQUEST","sendMessage","lastError","getIframePort_","getChromeRuntimePort_","port","connect","setTimeout","WrappedChromeRuntimePort_","prototype","postMessage","message","addEventListener","eventName","handler","name","toLowerCase","onMessage","addListener","console","iframeOrigin","iframe","document","createElement","src","setAttribute","body","appendChild","hasCalledBack","channel","port1","ready","data","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","length","responseHandler_","shift","push","reqId","cb","opt_timeoutSeconds","req","timeoutSeconds","requestId","U2F_REGISTER_REQUEST","wrapU2FTransportError","originalError","id","webSafe64","base64","replace","attemptExchange","apdu","timeoutMillis","scrambleKey","unwrap","keyHandle","key","result","Buffer","alloc","i","wrapApdu","from","signRequest","version","toString","origin","signatureData","substring","transportInstances","TransportU2F","_Transport","_super","_this","value","_open","mark","_callee","_","_args","wrap","_context","prev","next","undefined","abrupt","stop","_x","_exchange","_callee2","_context2","exchangeTimeout","sent","t0","forEach","t","emit","_x2","list","supported","listen","observer","unsubscribed","descriptor","complete","unsubscribe"],"mappings":"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","file":"static/js/33.c6505f82.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = require('./lib/u2f-api');","'use strict';\n\nmodule.exports = API;\n\nvar chromeApi = require('./google-u2f-api'); // Feature detection (yes really)\n\n\nvar isBrowser = typeof navigator !== 'undefined' && !!navigator.userAgent;\nvar isSafari = isBrowser && navigator.userAgent.match(/Safari\\//) && !navigator.userAgent.match(/Chrome\\//);\nvar isEDGE = isBrowser && navigator.userAgent.match(/Edge\\/1[2345]/);\nvar _backend = null;\n\nfunction getBackend(Promise) {\n  if (!_backend) _backend = new Promise(function (resolve, reject) {\n    function notSupported() {\n      // Note; {native: true} means *not* using Google's hack\n      resolve({\n        u2f: null,\n        native: true\n      });\n    }\n\n    if (!isBrowser) return notSupported();\n    if (isSafari) // Safari doesn't support U2F, and the Safari-FIDO-U2F\n      // extension lacks full support (Multi-facet apps), so we\n      // block it until proper support.\n      return notSupported();\n    var hasNativeSupport = typeof window.u2f !== 'undefined' && typeof window.u2f.sign === 'function';\n    if (hasNativeSupport) resolve({\n      u2f: window.u2f,\n      native: true\n    });\n    if (isEDGE) // We don't want to check for Google's extension hack on EDGE\n      // as it'll cause trouble (popups, etc)\n      return notSupported();\n    if (location.protocol === 'http:') // U2F isn't supported over http, only https\n      return notSupported();\n    if (typeof MessageChannel === 'undefined') // Unsupported browser, the chrome hack would throw\n      return notSupported(); // Test for google extension support\n\n    chromeApi.isSupported(function (ok) {\n      if (ok) resolve({\n        u2f: chromeApi,\n        native: false\n      });else notSupported();\n    });\n  });\n  return _backend;\n}\n\nfunction API(Promise) {\n  return {\n    isSupported: isSupported.bind(Promise),\n    ensureSupport: ensureSupport.bind(Promise),\n    register: register.bind(Promise),\n    sign: sign.bind(Promise),\n    ErrorCodes: API.ErrorCodes,\n    ErrorNames: API.ErrorNames\n  };\n}\n\nAPI.ErrorCodes = {\n  CANCELLED: -1,\n  OK: 0,\n  OTHER_ERROR: 1,\n  BAD_REQUEST: 2,\n  CONFIGURATION_UNSUPPORTED: 3,\n  DEVICE_INELIGIBLE: 4,\n  TIMEOUT: 5\n};\nAPI.ErrorNames = {\n  \"-1\": \"CANCELLED\",\n  \"0\": \"OK\",\n  \"1\": \"OTHER_ERROR\",\n  \"2\": \"BAD_REQUEST\",\n  \"3\": \"CONFIGURATION_UNSUPPORTED\",\n  \"4\": \"DEVICE_INELIGIBLE\",\n  \"5\": \"TIMEOUT\"\n};\n\nfunction makeError(msg, err) {\n  var code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR\n\n  var type = API.ErrorNames['' + code];\n  var error = new Error(msg);\n  error.metaData = {\n    type: type,\n    code: code\n  };\n  return error;\n}\n\nfunction deferPromise(Promise, promise) {\n  var ret = {};\n  ret.promise = new Promise(function (resolve, reject) {\n    ret.resolve = resolve;\n    ret.reject = reject;\n    promise.then(resolve, reject);\n  });\n  /**\n   * Reject request promise and disconnect port if 'disconnect' flag is true\n   * @param {string} msg\n   * @param {boolean} disconnect\n   */\n\n  ret.promise.cancel = function (msg, disconnect) {\n    getBackend(Promise).then(function (backend) {\n      if (disconnect && !backend.native) backend.u2f.disconnect();\n      ret.reject(makeError(msg, {\n        errorCode: -1\n      }));\n    });\n  };\n\n  return ret;\n}\n\nfunction defer(Promise, fun) {\n  return deferPromise(Promise, new Promise(function (resolve, reject) {\n    try {\n      fun && fun(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }));\n}\n\nfunction isSupported() {\n  var Promise = this;\n  return getBackend(Promise).then(function (backend) {\n    return !!backend.u2f;\n  });\n}\n\nfunction _ensureSupport(backend) {\n  if (!backend.u2f) {\n    if (location.protocol === 'http:') throw new Error(\"U2F isn't supported over http, only https\");\n    throw new Error(\"U2F not supported\");\n  }\n}\n\nfunction ensureSupport() {\n  var Promise = this;\n  return getBackend(Promise).then(_ensureSupport);\n}\n\nfunction register(registerRequests, signRequests\n/* = null */\n, timeout) {\n  var Promise = this;\n  if (!Array.isArray(registerRequests)) registerRequests = [registerRequests];\n\n  if (typeof signRequests === 'number' && typeof timeout === 'undefined') {\n    timeout = signRequests;\n    signRequests = null;\n  }\n\n  if (!signRequests) signRequests = [];\n  return deferPromise(Promise, getBackend(Promise).then(function (backend) {\n    _ensureSupport(backend);\n\n    var native = backend.native;\n    var u2f = backend.u2f;\n    return new Promise(function (resolve, reject) {\n      function cbNative(response) {\n        if (response.errorCode) reject(makeError(\"Registration failed\", response));else {\n          delete response.errorCode;\n          resolve(response);\n        }\n      }\n\n      function cbChrome(err, response) {\n        if (err) reject(err);else if (response.errorCode) reject(makeError(\"Registration failed\", response));else resolve(response);\n      }\n\n      if (native) {\n        var appId = registerRequests[0].appId;\n        u2f.register(appId, registerRequests, signRequests, cbNative, timeout);\n      } else {\n        u2f.register(registerRequests, signRequests, cbChrome, timeout);\n      }\n    });\n  })).promise;\n}\n\nfunction sign(signRequests, timeout) {\n  var Promise = this;\n  if (!Array.isArray(signRequests)) signRequests = [signRequests];\n  return deferPromise(Promise, getBackend(Promise).then(function (backend) {\n    _ensureSupport(backend);\n\n    var native = backend.native;\n    var u2f = backend.u2f;\n    return new Promise(function (resolve, reject) {\n      function cbNative(response) {\n        if (response.errorCode) reject(makeError(\"Sign failed\", response));else {\n          delete response.errorCode;\n          resolve(response);\n        }\n      }\n\n      function cbChrome(err, response) {\n        if (err) reject(err);else if (response.errorCode) reject(makeError(\"Sign failed\", response));else resolve(response);\n      }\n\n      if (native) {\n        var appId = signRequests[0].appId;\n        var challenge = signRequests[0].challenge;\n        u2f.sign(appId, challenge, signRequests, cbNative, timeout);\n      } else {\n        u2f.sign(signRequests, cbChrome, timeout);\n      }\n    });\n  })).promise;\n}\n\nfunction makeDefault(func) {\n  API[func] = function () {\n    if (!global.Promise) // This is very unlikely to ever happen, since browsers\n      // supporting U2F will most likely support Promises.\n      throw new Error(\"The platform doesn't natively support promises\");\n    var args = [].slice.call(arguments);\n    return API(global.Promise)[func].apply(null, args);\n  };\n} // Provide default functions using the built-in Promise if available.\n\n\nmakeDefault('isSupported');\nmakeDefault('ensureSupport');\nmakeDefault('register');\nmakeDefault('sign');","// Copyright 2014 Google Inc. All rights reserved\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n/** Namespace for the U2F api.\n * @type {Object}\n */\n\nvar u2f = u2f || {};\nmodule.exports = u2f; // Adaptation for u2f-api package\n\n/**\n * The U2F extension id\n * @type {string}\n * @const\n */\n\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\n\nu2f.MessageTypes = {\n  'U2F_REGISTER_REQUEST': 'u2f_register_request',\n  'U2F_SIGN_REQUEST': 'u2f_sign_request',\n  'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n  'U2F_SIGN_RESPONSE': 'u2f_sign_response'\n};\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\n\nu2f.ErrorCodes = {\n  'OK': 0,\n  'OTHER_ERROR': 1,\n  'BAD_REQUEST': 2,\n  'CONFIGURATION_UNSUPPORTED': 3,\n  'DEVICE_INELIGIBLE': 4,\n  'TIMEOUT': 5\n};\n/**\n * A message type for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   signRequests: Array.<u2f.SignRequest>,\n *   registerRequests: ?Array.<u2f.RegisterRequest>,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\n\nu2f.Request;\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\n\nu2f.Response;\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\n\nu2f.Error;\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\n\nu2f.SignRequest;\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\n\nu2f.SignResponse;\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   appId: string\n * }}\n */\n\nu2f.RegisterRequest;\n/**\n * Data object for a registration response.\n * @typedef {{\n *   registrationData: string,\n *   clientData: string\n * }}\n */\n\nu2f.RegisterResponse; // Low level MessagePort API support\n\n/**\n * Call MessagePort disconnect\n */\n\nu2f.disconnect = function () {\n  if (u2f.port_ && u2f.port_.port_) {\n    u2f.port_.port_.disconnect();\n    u2f.port_ = null;\n  }\n};\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\n\n\nu2f.getMessagePort = function (callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function () {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n/**\n * Connects directly to the extension via chrome.runtime.connect\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\n\n\nu2f.getChromeRuntimePort_ = function (callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID, {\n    'includeTlsChannelId': true\n  });\n  setTimeout(function () {\n    callback(null, new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\n\n\nu2f.WrappedChromeRuntimePort_ = function (port) {\n  this.port_ = port;\n};\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\n\n\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function (message) {\n  this.port_.postMessage(message);\n};\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\n\n\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener = function (eventName, handler) {\n  var name = eventName.toLowerCase();\n\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function (message) {\n      // Emulate a minimal MessageEvent object\n      handler({\n        'data': message\n      });\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\n\n\nu2f.getIframePort_ = function (callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n  var hasCalledBack = false;\n  var channel = new MessageChannel();\n\n  var ready = function ready(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n\n      if (!hasCalledBack) {\n        hasCalledBack = true;\n        callback(null, channel.port1);\n      }\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n  iframe.addEventListener('load', function () {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  }); // Give this 200ms to initialize, after that, we treat this method as failed\n\n  setTimeout(function () {\n    if (!hasCalledBack) {\n      hasCalledBack = true;\n      callback(new Error(\"IFrame extension not supported\"));\n    }\n  }, 200);\n}; // High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\n\n\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\n\nu2f.port_ = null;\n/**\n * Callbacks waiting for a port\n * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\n\nu2f.waitingForPort_ = [];\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\n\nu2f.reqCounter_ = 0;\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\n\nu2f.callbackMap_ = {};\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\n\nu2f.getPortSingleton_ = function (callback) {\n  if (u2f.port_) {\n    callback(null, u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function (err, port) {\n        if (!err) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n          /** @type {function(Event)} */\n          u2f.responseHandler_);\n        } // Careful, here be async callbacks. Maybe.\n\n\n        while (u2f.waitingForPort_.length) {\n          u2f.waitingForPort_.shift()(err, port);\n        }\n      });\n    }\n\n    u2f.waitingForPort_.push(callback);\n  }\n};\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\n\n\nu2f.responseHandler_ = function (message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(null, response['responseData']);\n};\n/**\n * Calls the callback with true or false as first and only argument\n * @param {Function} callback\n */\n\n\nu2f.isSupported = function (callback) {\n  u2f.getPortSingleton_(function (err, port) {\n    callback(!err);\n  });\n};\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\n\n\nu2f.sign = function (signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function (err, port) {\n    if (err) return callback(err);\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {Array.<u2f.RegisterRequest>} registerRequests\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\n\n\nu2f.register = function (registerRequests, signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function (err, port) {\n    if (err) return callback(err);\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};","import _regeneratorRuntime from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _createClass from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  var err = new TransportError(message, id); // $FlowFixMe\n\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu, key) {\n  var result = Buffer.alloc(apdu.length);\n\n  for (var i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n\n  return result;\n} // Convert from normal to web-safe, strip trailing \"=\"s\n\n\nvar webSafe64 = function webSafe64(base64) {\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}; // Convert from web-safe to normal, add trailing \"=\"s\n\n\nvar normal64 = function normal64(base64) {\n  return base64.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"==\".substring(0, 3 * base64.length % 4);\n};\n\nfunction attemptExchange(apdu, timeoutMillis, scrambleKey, unwrap) {\n  var keyHandle = wrapApdu(apdu, scrambleKey);\n  var challenge = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  var signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then(function (response) {\n    var signatureData = response.signatureData;\n\n    if (typeof signatureData === \"string\") {\n      var data = Buffer.from(normal64(signatureData), \"base64\");\n      var result;\n\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nvar transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(function (t) {\n    return t.emit(\"disconnect\");\n  });\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\n\n\nvar TransportU2F = /*#__PURE__*/function (_Transport) {\n  _inherits(TransportU2F, _Transport);\n\n  var _super = _createSuper(TransportU2F);\n\n  _createClass(TransportU2F, null, [{\n    key: \"open\",\n\n    /*\n     */\n\n    /*\n     */\n\n    /**\n     * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n     */\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_) {\n        var _openTimeout,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _openTimeout = _args.length > 1 && _args[1] !== undefined ? _args[1] : 5000;\n                return _context.abrupt(\"return\", new TransportU2F());\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }]);\n\n  function TransportU2F() {\n    var _this;\n\n    _classCallCheck(this, TransportU2F);\n\n    _this = _super.call(this);\n    _this.scrambleKey = void 0;\n    _this.unwrap = true;\n    transportInstances.push(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  _createClass(TransportU2F, [{\n    key: \"exchange\",\n    value: function () {\n      var _exchange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(apdu) {\n        var isU2FError;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey, this.unwrap);\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](0);\n                isU2FError = typeof _context2.t0.metaData === \"object\";\n\n                if (!isU2FError) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                if (isTimeoutU2FError(_context2.t0)) {\n                  emitDisconnect();\n                } // the wrapping make error more usable and \"printable\" to the end user.\n\n\n                throw wrapU2FTransportError(_context2.t0, \"Failed to sign with Ledger device: U2F \" + _context2.t0.metaData.type, \"U2F_\" + _context2.t0.metaData.code);\n\n              case 14:\n                throw _context2.t0;\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 6]]);\n      }));\n\n      function exchange(_x2) {\n        return _exchange.apply(this, arguments);\n      }\n\n      return exchange;\n    }()\n    /**\n     */\n\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey(scrambleKey) {\n      this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n    }\n    /**\n     */\n\n  }, {\n    key: \"setUnwrap\",\n    value: function setUnwrap(unwrap) {\n      this.unwrap = unwrap;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      // u2f have no way to clean things up\n      return Promise.resolve();\n    }\n  }]);\n\n  return TransportU2F;\n}(Transport);\n\nexport { TransportU2F as default };\nTransportU2F.isSupported = isSupported;\n\nTransportU2F.list = function () {\n  return (// this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then(function (supported) {\n      return supported ? [null] : [];\n    })\n  );\n};\n\nTransportU2F.listen = function (observer) {\n  var unsubscribed = false;\n  isSupported().then(function (supported) {\n    if (unsubscribed) return;\n\n    if (supported) {\n      observer.next({\n        type: \"add\",\n        descriptor: null\n      });\n      observer.complete();\n    } else {\n      observer.error(new TransportError(\"U2F browser support is needed for Ledger. \" + \"Please use Chrome, Opera or Firefox with a U2F extension. \" + \"Also make sure you're on an HTTPS connection\", \"U2FNotSupported\"));\n    }\n  });\n  return {\n    unsubscribe: function unsubscribe() {\n      unsubscribed = true;\n    }\n  };\n};"],"sourceRoot":""}