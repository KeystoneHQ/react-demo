{"version":3,"sources":["../node_modules/bs58check/index.js","../node_modules/bs58check/base.js","../node_modules/hdkey/lib/hdkey.js","../node_modules/hdkey/node_modules/secp256k1/elliptic.js","../node_modules/hdkey/node_modules/secp256k1/lib/index.js","../node_modules/hdkey/node_modules/secp256k1/lib/elliptic.js"],"names":["createHash","bs58checkBase","module","exports","buffer","tmp","update","digest","base58","Buffer","checksumFn","decodeRaw","payload","slice","checksum","newChecksum","encode","concat","length","decode","string","Error","decodeUnsafe","assert","crypto","bs58check","secp256k1","MASTER_SECRET","from","BITCOIN_VERSIONS","private","public","HDKey","versions","this","depth","index","_privateKey","_publicKey","chainCode","_fingerprint","parentFingerprint","serialize","hdkey","version","key","allocUnsafe","writeUInt32BE","writeUInt8","fingerprint","copy","hash160","buf","sha","Object","defineProperty","prototype","get","_identifier","identifier","set","value","equal","privateKeyVerify","publicKeyCreate","publicKey","readUInt32BE","publicKeyVerify","publicKeyConvert","alloc","privateKey","derive","path","entries","split","forEach","c","i","hardened","childIndex","parseInt","deriveChild","test","data","isHardened","indexBuffer","pk","zb","I","createHmac","IL","IR","hd","privateKeyTweakAdd","err","publicKeyTweakAdd","sign","hash","ecdsaSign","signature","verify","ecdsaVerify","Uint8Array","wipePrivateData","randomBytes","toJSON","xpriv","privateExtendedKey","xpub","publicExtendedKey","fromMasterSeed","seedBuffer","fromExtendedKey","base58key","keyBuffer","readUInt8","fromJSON","obj","HARDENED_OFFSET","_createForOfIteratorHelper","errors","cond","msg","isUint8Array","name","undefined","Array","isArray","numbers","join","includes","_msg","isCompressed","toTypeString","getAssertedOutput","output","arguments","len","toString","call","contextRandomize","seed","seckey","privateKeyNegate","tweak","privateKeyTweakMul","pubkey","compressed","publicKeyNegate","publicKeyCombine","pubkeys","_step","_iterator","s","n","done","e","f","publicKeyTweakMul","signatureNormalize","sig","signatureExport","outputlen","signatureImport","msg32","options","noncefn","recid","ecdsaRecover","ecdh","hashfn","xbuf","ybuf","ec","EC","ecparams","curve","BN","constructor","loadPublicKey","first","x","cmp","p","y","toRed","red","redSqr","redIMul","redIAdd","b","redSqrt","isOdd","redNeg","keyPair","pub","loadCompressedPublicKey","subarray","x3","redISub","isZero","loadUncompressedPublicKey","savePublicKey","point","bn","negate","sub","umod","toArrayLike","iadd","isub","tweaked","imul","keyFromPrivate","getPublic","pair","pairs","_i","add","isInfinity","g","mul","r","nh","sigR","sigS","lenR","posR","lenS","posS","message","_noncefn","counter","nonce","d","canonical","k","pers","recoveryParam","sigObj","sigr","sigs","recoverPubKey","scalar","_data","sha256","getX","toArray","_i2","getY","_i3"],"mappings":"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","file":"static/js/33.06ac5668.chunk.js","sourcesContent":["'use strict';\n\nvar createHash = require('create-hash');\n\nvar bs58checkBase = require('./base'); // SHA256(SHA256(buffer))\n\n\nfunction sha256x2(buffer) {\n  var tmp = createHash('sha256').update(buffer).digest();\n  return createHash('sha256').update(tmp).digest();\n}\n\nmodule.exports = bs58checkBase(sha256x2);","'use strict';\n\nvar base58 = require('bs58');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode(payload) {\n    var checksum = checksumFn(payload);\n    return base58.encode(Buffer.concat([payload, checksum], payload.length + 4));\n  }\n\n  function decodeRaw(buffer) {\n    var payload = buffer.slice(0, -4);\n    var checksum = buffer.slice(-4);\n    var newChecksum = checksumFn(payload);\n    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;\n    return payload;\n  } // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n\n\n  function decodeUnsafe(string) {\n    var buffer = base58.decodeUnsafe(string);\n    if (!buffer) return;\n    return decodeRaw(buffer);\n  }\n\n  function decode(string) {\n    var buffer = base58.decode(string);\n    var payload = decodeRaw(buffer, checksumFn);\n    if (!payload) throw new Error('Invalid checksum');\n    return payload;\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  };\n};","var assert = require('assert');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar crypto = require('crypto');\n\nvar bs58check = require('bs58check');\n\nvar secp256k1 = require('secp256k1');\n\nvar MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\nvar HARDENED_OFFSET = 0x80000000;\nvar LEN = 78; // Bitcoin hardcoded by default, can use package `coininfo` for others\n\nvar BITCOIN_VERSIONS = {\n  private: 0x0488ADE4,\n  public: 0x0488B21E\n};\n\nfunction HDKey(versions) {\n  this.versions = versions || BITCOIN_VERSIONS;\n  this.depth = 0;\n  this.index = 0;\n  this._privateKey = null;\n  this._publicKey = null;\n  this.chainCode = null;\n  this._fingerprint = 0;\n  this.parentFingerprint = 0;\n}\n\nObject.defineProperty(HDKey.prototype, 'fingerprint', {\n  get: function get() {\n    return this._fingerprint;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'identifier', {\n  get: function get() {\n    return this._identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'pubKeyHash', {\n  get: function get() {\n    return this.identifier;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateKey', {\n  get: function get() {\n    return this._privateKey;\n  },\n  set: function set(value) {\n    assert.equal(value.length, 32, 'Private key must be 32 bytes.');\n    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key');\n    this._privateKey = value;\n    this._publicKey = Buffer.from(secp256k1.publicKeyCreate(value, true));\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicKey', {\n  get: function get() {\n    return this._publicKey;\n  },\n  set: function set(value) {\n    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.');\n    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key');\n    this._publicKey = Buffer.from(secp256k1.publicKeyConvert(value, true)); // force compressed point\n\n    this._identifier = hash160(this.publicKey);\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0);\n    this._privateKey = null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'privateExtendedKey', {\n  get: function get() {\n    if (this._privateKey) return bs58check.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])));else return null;\n  }\n});\nObject.defineProperty(HDKey.prototype, 'publicExtendedKey', {\n  get: function get() {\n    return bs58check.encode(serialize(this, this.versions.public, this.publicKey));\n  }\n});\n\nHDKey.prototype.derive = function (path) {\n  if (path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return this;\n  }\n\n  var entries = path.split('/');\n  var hdkey = this;\n  entries.forEach(function (c, i) {\n    if (i === 0) {\n      assert(/^[mM]{1}/.test(c), 'Path must start with \"m\" or \"M\"');\n      return;\n    }\n\n    var hardened = c.length > 1 && c[c.length - 1] === \"'\";\n    var childIndex = parseInt(c, 10); // & (HARDENED_OFFSET - 1)\n\n    assert(childIndex < HARDENED_OFFSET, 'Invalid index');\n    if (hardened) childIndex += HARDENED_OFFSET;\n    hdkey = hdkey.deriveChild(childIndex);\n  });\n  return hdkey;\n};\n\nHDKey.prototype.deriveChild = function (index) {\n  var isHardened = index >= HARDENED_OFFSET;\n  var indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  var data;\n\n  if (isHardened) {\n    // Hardened child\n    assert(this.privateKey, 'Could not derive hardened child key');\n    var pk = this.privateKey;\n    var zb = Buffer.alloc(1, 0);\n    pk = Buffer.concat([zb, pk]); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data = Buffer.concat([pk, indexBuffer]);\n  } else {\n    // Normal child\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data = Buffer.concat([this.publicKey, indexBuffer]);\n  }\n\n  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hd = new HDKey(this.versions); // Private parent key -> private child key\n\n  if (this.privateKey) {\n    // ki = parse256(IL) + kpar (mod n)\n    try {\n      hd.privateKey = Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(this.privateKey), IL)); // throw if IL >= n || (privateKey + IL) === 0\n    } catch (err) {\n      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    } // Public parent key -> public child key\n\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    try {\n      hd.publicKey = Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true)); // throw if IL >= n || (g**IL + publicKey) is infinity\n    } catch (err) {\n      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  hd.chainCode = IR;\n  hd.depth = this.depth + 1;\n  hd.parentFingerprint = this.fingerprint; // .readUInt32BE(0)\n\n  hd.index = index;\n  return hd;\n};\n\nHDKey.prototype.sign = function (hash) {\n  return Buffer.from(secp256k1.ecdsaSign(hash, this.privateKey).signature);\n};\n\nHDKey.prototype.verify = function (hash, signature) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(hash), Uint8Array.from(this.publicKey));\n};\n\nHDKey.prototype.wipePrivateData = function () {\n  if (this._privateKey) crypto.randomBytes(this._privateKey.length).copy(this._privateKey);\n  this._privateKey = null;\n  return this;\n};\n\nHDKey.prototype.toJSON = function () {\n  return {\n    xpriv: this.privateExtendedKey,\n    xpub: this.publicExtendedKey\n  };\n};\n\nHDKey.fromMasterSeed = function (seedBuffer, versions) {\n  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var hdkey = new HDKey(versions);\n  hdkey.chainCode = IR;\n  hdkey.privateKey = IL;\n  return hdkey;\n};\n\nHDKey.fromExtendedKey = function (base58key, versions) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  versions = versions || BITCOIN_VERSIONS;\n  var hdkey = new HDKey(versions);\n  var keyBuffer = bs58check.decode(base58key);\n  var version = keyBuffer.readUInt32BE(0);\n  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public');\n  hdkey.depth = keyBuffer.readUInt8(4);\n  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5);\n  hdkey.index = keyBuffer.readUInt32BE(9);\n  hdkey.chainCode = keyBuffer.slice(13, 45);\n  var key = keyBuffer.slice(45);\n\n  if (key.readUInt8(0) === 0) {\n    // private\n    assert(version === versions.private, 'Version mismatch: version does not match private');\n    hdkey.privateKey = key.slice(1); // cut off first 0x0 byte\n  } else {\n    assert(version === versions.public, 'Version mismatch: version does not match public');\n    hdkey.publicKey = key;\n  }\n\n  return hdkey;\n};\n\nHDKey.fromJSON = function (obj) {\n  return HDKey.fromExtendedKey(obj.xpriv);\n};\n\nfunction serialize(hdkey, version, key) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  var buffer = Buffer.allocUnsafe(LEN);\n  buffer.writeUInt32BE(version, 0);\n  buffer.writeUInt8(hdkey.depth, 4);\n  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000;\n  buffer.writeUInt32BE(fingerprint, 5);\n  buffer.writeUInt32BE(hdkey.index, 9);\n  hdkey.chainCode.copy(buffer, 13);\n  key.copy(buffer, 45);\n  return buffer;\n}\n\nfunction hash160(buf) {\n  var sha = crypto.createHash('sha256').update(buf).digest();\n  return crypto.createHash('ripemd160').update(sha).digest();\n}\n\nHDKey.HARDENED_OFFSET = HARDENED_OFFSET;\nmodule.exports = HDKey;","module.exports = require('./lib')(require('./lib/elliptic'));","var _createForOfIteratorHelper = require(\"/Users/sora/keystone/react-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n};\n\nfunction assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\n\nfunction isUint8Array(name, value, length) {\n  assert(value instanceof Uint8Array, \"Expected \".concat(name, \" to be an Uint8Array\"));\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      var numbers = length.join(', ');\n      var msg = \"Expected \".concat(name, \" to be an Uint8Array with length [\").concat(numbers, \"]\");\n      assert(length.includes(value.length), msg);\n    } else {\n      var _msg = \"Expected \".concat(name, \" to be an Uint8Array with length \").concat(length);\n\n      assert(value.length === length, _msg);\n    }\n  }\n}\n\nfunction isCompressed(value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');\n}\n\nfunction getAssertedOutput() {\n  var output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (len) {\n    return new Uint8Array(len);\n  };\n  var length = arguments.length > 1 ? arguments[1] : undefined;\n  if (typeof output === 'function') output = output(length);\n  isUint8Array('output', output, length);\n  return output;\n}\n\nfunction toTypeString(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nmodule.exports = function (secp256k1) {\n  return {\n    contextRandomize: function contextRandomize(seed) {\n      assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');\n      if (seed !== null) isUint8Array('seed', seed, 32);\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n      }\n    },\n    privateKeyVerify: function privateKeyVerify(seckey) {\n      isUint8Array('private key', seckey, 32);\n      return secp256k1.privateKeyVerify(seckey) === 0;\n    },\n    privateKeyNegate: function privateKeyNegate(seckey) {\n      isUint8Array('private key', seckey, 32);\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    publicKeyVerify: function publicKeyVerify(pubkey) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      return secp256k1.publicKeyVerify(pubkey) === 0;\n    },\n    publicKeyCreate: function publicKeyCreate(seckey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('private key', seckey, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SECKEY_INVALID);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyConvert: function publicKeyConvert(pubkey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyNegate: function publicKeyNegate(pubkey) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyCombine: function publicKeyCombine(pubkeys) {\n      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var output = arguments.length > 2 ? arguments[2] : undefined;\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');\n\n      var _iterator = _createForOfIteratorHelper(pubkeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pubkey = _step.value;\n          isUint8Array('public key', pubkey, [33, 65]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyTweakAdd: function publicKeyTweakAdd(pubkey, tweak) {\n      var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    publicKeyTweakMul: function publicKeyTweakMul(pubkey, tweak) {\n      var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    signatureNormalize: function signatureNormalize(sig) {\n      isUint8Array('signature', sig, 64);\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n      }\n    },\n    signatureExport: function signatureExport(sig, output) {\n      isUint8Array('signature', sig, 64);\n      output = getAssertedOutput(output, 72);\n      var obj = {\n        output: output,\n        outputlen: 72\n      };\n\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen);\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    signatureImport: function signatureImport(sig, output) {\n      isUint8Array('signature', sig);\n      output = getAssertedOutput(output, 64);\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaSign: function ecdsaSign(msg32, seckey) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('message', msg32, 32);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');\n      output = getAssertedOutput(output, 64);\n      var obj = {\n        signature: output,\n        recid: null\n      };\n\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj;\n\n        case 1:\n          throw new Error(errors.SIGN);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64);\n      isUint8Array('message', msg32, 32);\n      isUint8Array('public key', pubkey, [33, 65]);\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true;\n\n        case 3:\n          return false;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE);\n      }\n    },\n    ecdsaRecover: function ecdsaRecover(sig, recid, msg32) {\n      var compressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var output = arguments.length > 4 ? arguments[4] : undefined;\n      isUint8Array('signature', sig, 64);\n      assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');\n      isUint8Array('message', msg32, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.RECOVER);\n\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdh: function ecdh(pubkey, seckey) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);\n        isUint8Array('output', output);\n      } else {\n        output = getAssertedOutput(output, 32);\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.ECDH);\n      }\n    }\n  };\n};","var EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve; // Hack, we can not use bn.js@5, while elliptic uses bn.js@4\n// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758\n\nvar BN = ecparams.n.constructor;\n\nfunction loadCompressedPublicKey(first, xbuf) {\n  var x = new BN(xbuf); // overflow\n\n  if (x.cmp(ecparams.p) >= 0) return null;\n  x = x.toRed(ecparams.red); // compute corresponding Y\n\n  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();\n  if (first === 0x03 !== y.isOdd()) y = y.redNeg();\n  return ec.keyPair({\n    pub: {\n      x: x,\n      y: y\n    }\n  });\n}\n\nfunction loadUncompressedPublicKey(first, xbuf, ybuf) {\n  var x = new BN(xbuf);\n  var y = new BN(ybuf); // overflow\n\n  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;\n  x = x.toRed(ecparams.red);\n  y = y.toRed(ecparams.red); // is odd flag\n\n  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null; // x*x*x + b = y*y\n\n  var x3 = x.redSqr().redIMul(x);\n  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;\n  return ec.keyPair({\n    pub: {\n      x: x,\n      y: y\n    }\n  });\n}\n\nfunction loadPublicKey(pubkey) {\n  // length should be validated in interface\n  var first = pubkey[0];\n\n  switch (first) {\n    case 0x02:\n    case 0x03:\n      if (pubkey.length !== 33) return null;\n      return loadCompressedPublicKey(first, pubkey.subarray(1, 33));\n\n    case 0x04:\n    case 0x06:\n    case 0x07:\n      if (pubkey.length !== 65) return null;\n      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));\n\n    default:\n      return null;\n  }\n}\n\nfunction savePublicKey(output, point) {\n  var pubkey = point.encode(null, output.length === 33); // Loop should be faster because we do not need create extra Uint8Array\n  // output.set(new Uint8Array(pubkey))\n\n  for (var i = 0; i < output.length; ++i) {\n    output[i] = pubkey[i];\n  }\n}\n\nmodule.exports = {\n  contextRandomize: function contextRandomize() {\n    return 0;\n  },\n  privateKeyVerify: function privateKeyVerify(seckey) {\n    var bn = new BN(seckey);\n    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;\n  },\n  privateKeyNegate: function privateKeyNegate(seckey) {\n    var bn = new BN(seckey);\n    var negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(negate);\n    return 0;\n  },\n  privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {\n    var bn = new BN(tweak);\n    if (bn.cmp(ecparams.n) >= 0) return 1;\n    bn.iadd(new BN(seckey));\n    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);\n    if (bn.isZero()) return 1;\n    var tweaked = bn.toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(tweaked);\n    return 0;\n  },\n  privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {\n    var bn = new BN(tweak);\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n    bn.imul(new BN(seckey));\n    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);\n    var tweaked = bn.toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(tweaked);\n    return 0;\n  },\n  publicKeyVerify: function publicKeyVerify(pubkey) {\n    var pair = loadPublicKey(pubkey);\n    return pair === null ? 1 : 0;\n  },\n  publicKeyCreate: function publicKeyCreate(output, seckey) {\n    var bn = new BN(seckey);\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n    var point = ec.keyFromPrivate(seckey).getPublic();\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyConvert: function publicKeyConvert(output, pubkey) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    var point = pair.getPublic();\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyNegate: function publicKeyNegate(output, pubkey) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    var point = pair.getPublic();\n    point.y = point.y.redNeg();\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyCombine: function publicKeyCombine(output, pubkeys) {\n    var pairs = new Array(pubkeys.length);\n\n    for (var i = 0; i < pubkeys.length; ++i) {\n      pairs[i] = loadPublicKey(pubkeys[i]);\n      if (pairs[i] === null) return 1;\n    }\n\n    var point = pairs[0].getPublic();\n\n    for (var _i = 1; _i < pairs.length; ++_i) {\n      point = point.add(pairs[_i].pub);\n    }\n\n    if (point.isInfinity()) return 2;\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyTweakAdd: function publicKeyTweakAdd(output, pubkey, tweak) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    tweak = new BN(tweak);\n    if (tweak.cmp(ecparams.n) >= 0) return 2;\n    var point = pair.getPublic().add(ecparams.g.mul(tweak));\n    if (point.isInfinity()) return 2;\n    savePublicKey(output, point);\n    return 0;\n  },\n  publicKeyTweakMul: function publicKeyTweakMul(output, pubkey, tweak) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    tweak = new BN(tweak);\n    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;\n    var point = pair.getPublic().mul(tweak);\n    savePublicKey(output, point);\n    return 0;\n  },\n  signatureNormalize: function signatureNormalize(sig) {\n    var r = new BN(sig.subarray(0, 32));\n    var s = new BN(sig.subarray(32, 64));\n    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;\n\n    if (s.cmp(ec.nh) === 1) {\n      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);\n    }\n\n    return 0;\n  },\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureExport: function signatureExport(obj, sig) {\n    var sigR = sig.subarray(0, 32);\n    var sigS = sig.subarray(32, 64);\n    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;\n    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;\n    var output = obj.output; // Prepare R\n\n    var r = output.subarray(4, 4 + 33);\n    r[0] = 0x00;\n    r.set(sigR, 1);\n    var lenR = 33;\n    var posR = 0;\n\n    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR) {\n      ;\n    }\n\n    r = r.subarray(posR);\n    if (r[0] & 0x80) return 1;\n    if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) return 1; // Prepare S\n\n    var s = output.subarray(6 + 33, 6 + 33 + 33);\n    s[0] = 0x00;\n    s.set(sigS, 1);\n    var lenS = 33;\n    var posS = 0;\n\n    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS) {\n      ;\n    }\n\n    s = s.subarray(posS);\n    if (s[0] & 0x80) return 1;\n    if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) return 1; // Set output length for return\n\n    obj.outputlen = 6 + lenR + lenS; // Output in specified format\n    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n\n    output[0] = 0x30;\n    output[1] = obj.outputlen - 2;\n    output[2] = 0x02;\n    output[3] = r.length;\n    output.set(r, 4);\n    output[4 + lenR] = 0x02;\n    output[5 + lenR] = s.length;\n    output.set(s, 6 + lenR);\n    return 0;\n  },\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureImport: function signatureImport(output, sig) {\n    if (sig.length < 8) return 1;\n    if (sig.length > 72) return 1;\n    if (sig[0] !== 0x30) return 1;\n    if (sig[1] !== sig.length - 2) return 1;\n    if (sig[2] !== 0x02) return 1;\n    var lenR = sig[3];\n    if (lenR === 0) return 1;\n    if (5 + lenR >= sig.length) return 1;\n    if (sig[4 + lenR] !== 0x02) return 1;\n    var lenS = sig[5 + lenR];\n    if (lenS === 0) return 1;\n    if (6 + lenR + lenS !== sig.length) return 1;\n    if (sig[4] & 0x80) return 1;\n    if (lenR > 1 && sig[4] === 0x00 && !(sig[5] & 0x80)) return 1;\n    if (sig[lenR + 6] & 0x80) return 1;\n    if (lenS > 1 && sig[lenR + 6] === 0x00 && !(sig[lenR + 7] & 0x80)) return 1;\n    var sigR = sig.subarray(4, 4 + lenR);\n    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);\n    if (sigR.length > 32) return 1;\n    var sigS = sig.subarray(6 + lenR);\n    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);\n    if (sigS.length > 32) throw new Error('S length is too long');\n    var r = new BN(sigR);\n    if (r.cmp(ecparams.n) >= 0) r = new BN(0);\n    var s = new BN(sig.subarray(6 + lenR));\n    if (s.cmp(ecparams.n) >= 0) s = new BN(0);\n    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);\n    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);\n    return 0;\n  },\n  ecdsaSign: function ecdsaSign(obj, message, seckey, data, noncefn) {\n    if (noncefn) {\n      var _noncefn = noncefn;\n\n      noncefn = function noncefn(counter) {\n        var nonce = _noncefn(message, seckey, null, data, counter);\n\n        var isValid = nonce instanceof Uint8Array && nonce.length === 32;\n        if (!isValid) throw new Error('This is the way');\n        return new BN(nonce);\n      };\n    }\n\n    var d = new BN(seckey);\n    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;\n    var sig;\n\n    try {\n      sig = ec.sign(message, seckey, {\n        canonical: true,\n        k: noncefn,\n        pers: data\n      });\n    } catch (err) {\n      return 1;\n    }\n\n    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0);\n    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32);\n    obj.recid = sig.recoveryParam;\n    return 0;\n  },\n  ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {\n    var sigObj = {\n      r: sig.subarray(0, 32),\n      s: sig.subarray(32, 64)\n    };\n    var sigr = new BN(sigObj.r);\n    var sigs = new BN(sigObj.s);\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 2;\n    var point = pair.getPublic();\n    var isValid = ec.verify(msg32, sigObj, point);\n    return isValid ? 0 : 3;\n  },\n  ecdsaRecover: function ecdsaRecover(output, sig, recid, msg32) {\n    var sigObj = {\n      r: sig.slice(0, 32),\n      s: sig.slice(32, 64)\n    };\n    var sigr = new BN(sigObj.r);\n    var sigs = new BN(sigObj.s);\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n    if (sigr.isZero() || sigs.isZero()) return 2; // Can throw `throw new Error('Unable to find sencond key candinate');`\n\n    var point;\n\n    try {\n      point = ec.recoverPubKey(msg32, sigObj, recid);\n    } catch (err) {\n      return 2;\n    }\n\n    savePublicKey(output, point);\n    return 0;\n  },\n  ecdh: function ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {\n    var pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    var scalar = new BN(seckey);\n    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;\n    var point = pair.getPublic().mul(scalar);\n\n    if (hashfn === undefined) {\n      var _data = point.encode(null, true);\n\n      var sha256 = ec.hash().update(_data).digest();\n\n      for (var i = 0; i < 32; ++i) {\n        output[i] = sha256[i];\n      }\n    } else {\n      if (!xbuf) xbuf = new Uint8Array(32);\n      var x = point.getX().toArray('be', 32);\n\n      for (var _i2 = 0; _i2 < 32; ++_i2) {\n        xbuf[_i2] = x[_i2];\n      }\n\n      if (!ybuf) ybuf = new Uint8Array(32);\n      var y = point.getY().toArray('be', 32);\n\n      for (var _i3 = 0; _i3 < 32; ++_i3) {\n        ybuf[_i3] = y[_i3];\n      }\n\n      var hash = hashfn(xbuf, ybuf, data);\n      var isValid = hash instanceof Uint8Array && hash.length === output.length;\n      if (!isValid) return 2;\n      output.set(hash);\n    }\n\n    return 0;\n  }\n};"],"sourceRoot":""}